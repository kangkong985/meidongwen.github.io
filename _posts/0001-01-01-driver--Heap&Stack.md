函数定义前加了几个数组定义，加了个对数组处理的函数，出现了HardFault_Handler的错误，不知道怎么解决！！！
因为局部变量是存放在栈区的，而全局变量在全局区(静态区)，如果栈区较小，会产生溢出。
修改启动代码
Stack_Size      EQU   0x00000800
对 stack size 进行设定太小。
栈不能开的太大，除了变量需要，调用的函数参数也需要压栈。

STM32出现HardFault_Handler故障的原因主要有两个方面：
（1）内存溢出或者访问越界。　　
（2）堆栈溢出

理解堆和栈的区别：

（1）栈区（stack）：由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似     于数据结构中的栈。
（2）堆区（heap）：一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配
     方式类似于数据结构中的链表。
（3）全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态
     变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系
     统自动释放。
（4）文字常量区：常量字符串就是存放在这里的。
（5）程序代码区：存放函数体的二进制代码。

例如：
    int a=0;                    //全局初始化区
    char *p1;                   //全局未初始化区
    main()
    {
     int b;                    //栈
     char s[]="abc";              //栈
     char *p3= "1234567";          //在文字常量区
     static int c =0 ;            //静态初始化区
     p1= (char *)malloc(10);         //堆区
     strcpy（p1,"123456");          //"123456"放在常量区
    }
所以堆和栈的区别：
    stack的空间由操作系统自动分配/释放，heap上的空间手动分配/释放。
    stack的空间有限，heap是很大的自由存储区。
    程序在编译期和函数分配内存都是在栈上进行，且程序运行中函数调用时参数的传递也是在栈上进行。

 

明白堆栈的分配原理后，我们也就明白了为什么说是栈溢出了，而没有说是堆栈溢出或者堆溢出，我们接下来再来分析什么导致了栈溢出，这会不难发现真凶是unsignedcharbuf[5000];，buf的开辟占用了很大的栈空间，超出了startup_stm32f10x_md.s文件中定义的空间大小，导致了栈的溢出。
问题总结：
1、函数内部变量占用空间较大时，定义为全局变量或者静态变量，减少堆栈的占用。
2、多使用指针解决数据的复制，同时减少内存的占用。