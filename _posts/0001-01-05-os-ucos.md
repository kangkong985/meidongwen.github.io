---
layout: post
os: true
comments: true
title:  "ucos"
excerpt: "..."
tag:
- os
- ucos


---



# reference

RTOS Projects Download Center：https://www.micrium.com/downloadcenter/

Online Documentation for all Micrium Products：https://doc.micrium.com/display/ucos/



# project



## src

STM32F429II-SK_OS3\Micrium\Software



## files

os\ucos\src\Micrium\Software\uC-CPU\ *.c
os\ucos\src\Micrium\Software\uC-CPU\ARM-Cortex-M4\RealView\cpu_c.c
os\ucos\src\Micrium\Software\uC-CPU\ARM-Cortex-M4\RealView\cpu_a.asm

os\ucos\src\Micrium\Software\uC-LIB\ *.c
os\ucos\src\Micrium\Software\uC-LIB\Ports\ARM-Cortex-M4\RealView\lib_mem_a.asm

os\ucos\src\Micrium\Software\uCOS-III\Source\ *.c
os\ucos\src\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView\os_cpu_c.c
os\ucos\src\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView\os_cpu_a.asm

os\ucos\app\ *.c



## modify



## Keil MDK

- include

..\os\ucos\Micrium\Software\uC-CPU
..\os\ucos\Micrium\Software\uC-CPU\ARM-Cortex-M4\RealView
..\os\ucos\Micrium\Software\uC-LIB
..\os\ucos\Micrium\Software\uC-LIB\Ports\ARM-Cortex-M4\RealView
..\os\ucos\Micrium\Software\uCOS-III\Source
..\os\ucos\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView

..\os\ucos\app



# CPU

CPU
CPU_IntDis

CPU_IntEn

CPU_IntSrcDis

CPU_IntSrcEn

CPU_IntSrcPendClr

CPU_IntSrcPrioGet

CPU_IntSrcPrioSet

CPU_SR_Save

CPU_SR_Restore

CPU_WaitForInt

CPU_WaitForExcept

CPU_RevBits

CPU_BitBandClr

CPU_BitBandSet

CPU_Init

CPU_SW_Exception

CPU_NameClr

CPU_NameGet

CPU_NameSet

CPU_TS_Get32

CPU_TS_Get64

CPU_TS_Update

CPU_TS_TmrFreqGet	

CPU_TS_TmrFreqSet

CPU_IntDisMeasMaxCurReset

CPU_IntDisMeasMaxCurGet

CPU_IntDisMeasMaxGet

CPU_IntDisMeasStart

CPU_IntDisMeasStop

CPU_CntLeadZeros

CPU_CntLeadZeros08

CPU_CntLeadZeros16

CPU_CntLeadZeros32

CPU_CntLeadZeros64

CPU_CntTrailZeros

CPU_CntTrailZeros08

CPU_CntTrailZeros16

CPU_CntTrailZeros32

CPU_CntTrailZeros64

# BSP

CPU_TS_TmrInit

CPU_TS_TmrRd

CPU_TS32_to_uSec

CPU_TS64_to_uSec



# OS_TASK

OS_TaskBlock
OS_TaskDbgListAdd
OS_TaskDbgListRemove
OS_TaskInit
OS_TaskInitTCB
OS_TaskQPost
OS_TaskResume
OS_TaskReturn 
OS_TaskSemPost
OS_TaskSuspend
OS_TaskChangePrio



# 系统内部功能

OSCfg_Init

OS_Dbg_Init

OS_IntQTaskInit

OS_IntQPost

OS_IntQRePost

OS_IntQTask


## PEND/POST MANAGEMENT 

OS_Pend
OS_PendAbort

OS_PendAbort1
OS_PendObjDel
OS_PendObjDel1
OS_Post
OS_Post1



## SCHEDULING
OS_Sched

OS_SchedLockTimeMeasStart

OS_SchedLockTimeMeasStop

OS_SchedRoundRobin



# 信号量

- 使能信号量：OS_CFG_SEM_EN置1，位置：os_cfg.h
  使能Type检查功能：OS_CFG_OBJ_TYPE_CHK_EN置1，位置：os_cfg.h
- 定义：在任务中添加一段“被锁代码段”，程序执行到被锁代码段之前，会请求某个信号量， 程序查看这个信号量是否存在，如果不存在，那么程序就会暂停在这边，直到系统中出现它需求的信号量，并且被它所获取，才能继续执行下去；
  所以常称被锁代码段是“上了锁的资源”，“请求某个信号量”的语句就是这个资源的“锁”，信号量就是“钥匙”
  在ucOS系统中，信号量是一个OS_SEM类型的结构变量，如下所示，定义位置：os.h

- 计数值：信号量的计数值是OS_SEM_CTR类型的变量；
  某个任务创建某个信号量，会设置该信号量的计数值的初始值；
  某个任务释放某个信号量，该信号量的计数值加1
  某个任务请求某个信号量，如果该信号量的计数值为0，那么该任务进入等待态；
  如果该信号量的计数值不为0，那么该任务就会获得这个信号量继续运行，同时该信号量的计数值减1；
- 信号量状态：
  - 虚无状态：信号量没有被创建
  - 存在状态：
    - 有效：计数值≠0
    - 无效：计数值= 0
- 二进制信号量：信号量的计数值只能取0或1
- 计数型信号量：信号量的计数值可以取0~255或0~65535或0~4294967295，取决于信号量的成员OS_SEM_CTR的定义
- OS_SEM	
  - Type：Type=OS_OBJ_TYPE_SEM，表明该结构类型变量表示信号量
  - NamePtr：内核对象的名称，字符串数组的首地址 (数组以NULL结尾)，字符串的长度没有限制，因为存储的是字符串的地址，而并非字符串本身
  - PendList：该内核对象的任务挂起列表
  - DbgPrevPtr：
  - DbgNextPtr：	
  - DbgNamePtr：
  - Ctr：该信号量的信号计数器的当前值
  - TS：每当信号量被释放，该信号量的TS成员就会更新为，释放时刻的时间戳，单位：时钟节拍

- 任务信号量

  每个任务在创建的同时也创建了该任务的内嵌信号量，一个任务对应一个任务信号量
  任务的SemCtr成员表示其内嵌信号量的计数值；
  操作任务信号量使用专门的服务函数：OSTaskSemSet()、OSTaskSemPend()、OSTaskSemPost()、OSTaskSemPendAbort
  任务信号量的计数值的初始值=0
  任务信号量只能被其对应的任务请求
  任务信号量只能被其它的任务释放

- OSSemCreate
  - 信号量实现状态转换：虚无状态到存在状态
  - 输入
    - OS_SEM指针，传递一个空白的OS_SEM变量的地址
    - CPU_CHAR指针，该信号量的名称 ，这里传递字符串数组的首地址 
    - OS_SEM_CTR变量，该信号量计数值的初始值
    - OS_ERR指针，传递一个空白的OS_ERR变量，用于存储错误信息

- OSSemDel
  - 需要使能：：OS_CFG_SEM_DEL_EN 置1，位置：os_cfg.h
    信号量实现状态转换：存在状态虚无状态；、
    本函数执行时会调用OS_SemClr()函数，OS_SemClr实现清空该信号量的所有成员
  - 输入
    - OS_SEM指针，要删除的目标信号量的地址
    - OS_OPT变量，OS_OPT_DEL_NO_PEND 	等到没有任务在请求这个信号量时再删除它
    - OS_OPT_DEL_ALWAYS，直接删除，正等待该信号量的任务相当于获取了该信号量
    - OS_ERR指针，传递一个空白的OS_ERR变量，用于存储错误信息
    
  - 输出
    - OS_OBJ_QTY变量，删除这个信号量的时刻，等待这个信号量的任务的数目

- OSSemSet
  - 使能：OS_CFG_SEM_SET_EN 置1，位置：os_cfg.h
  - 输入
    - OS_SEM指针	要操作的目标信号量的地址
    - OS_SEM_CTR变量	强制设置该信号量的计数值
    - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
- OSTaskSemSet
  - 输入
    - OS_TCB指针，要操作的目标任务信号量对应的任务的任务控制块的地址
    - OS_SEM_CTR变量，强制设置该信号量的计数值
    - OS_ERR指针，传递一个空白的OS_ERR变量，用于存储错误信息	

## 等待信号量

- OSSemPend

  - 使用
    - 任务A使用该函数的时刻，如果请求的信号量时有效的：那么任务A不必等待，直接继续执行，同时对应信号量的计数值减1
    - 如果请求的信号量时无效的，且OPT=OS_OPT_PEND_NON_BLOCKING：那么任务A就会进入等待态，任务A进入该信号量的任务挂起表；如果在等待超时到来之前，其他任务释放这个信号量，且任务A在该信号量的任务挂起表中优先级是最高的，那么任务A就成功获取该信号量，从等待态进入运行态，继续执行；同时对应信号量计数值减1
    - 如果在等待超时到来时，任务仍然没有获得请求的信号量，那么这个任务会取消等待该信号量，任务进入就绪状体，准备运行；同时函数返回超时的错误代码
    - 调用OS_SemDbgListAdd()函数：
      使能：OS_CFG_DBG_EN置1，定义位置：
      如果将调用该函数的任务要进入等待状态，那么该函数就会调用OS_SemDbgListAdd()函数，将该任务插入到该信号量的任务挂起表中
  - 输入	
    - OS_SEM指针，指定所等待的信号量(存在状态)的地址
    - OS_TICK变量，等待超时时间timeout；从从调用这个函数开始；单位：时钟节拍；仅在OS_OPT_PEND_BLOCKING模式下有效，timeout = 0表示没有超时时间，任务会一直等下去
    - OS_OPT变量，任务调用该函数的时刻，如果所等待的信号量处于无效状态
      - OS_OPT_PEND_BLOCKING：任务进入等待态，直到信号量被释放或超时
      - OS_OPT_PEND_NON_BLOCKING：任务不会等待，函数立即返回错误信息说明此信号量无效
    - CPU_TS指针，输入一个空白的CPU_TS类型变量的地址，所等待的信号量一旦被释放，其成员TS就会被更新，同时，将更新后的TS的值赋给这个CPU_TS类型变量；用户如果再获取任务继续执行时刻，就可以算出信号量从被释放到被接收的时间间隔。 
      OS_ERR指针，传递一个空白的OS_ERR变量，用于存储错误信息
       	

- OSTaskSemPend

  - 任务A调用OSTaskSemPend()函数，就会请求任务A自己的任务信号量
    任务信号量只能被其对应的任务请求

  - 输入	

    - OS_TICK变量,等待超时时间
    - OS_OPT变量
      - OS_OPT_PEND_BLOCKING	任务进入等待态，直到信号量被释放或超时
      - OS_OPT_PEND_NON_BLOCKING	任务不会等待，函数立即返回错误信息说明此信号量无效 	 	 	

    - CPU_TS指针，输入一个空白的CPU_TS类型变量，用于存储信号量释放的时刻的时间戳
    - OS_ERR指针，输入一个空白的OS_ERR变量，用于存储错误信息

  

- OSSemPendAbort

  - 使能：OS_CFG_SEM_PEND_ABORT_EN 置1，位置：os_cfg.h
  - 任务H运行过程中调用OSSemPend ()函数后进入等待态；
    就绪态中优先级最高的任务L进如运行态，任务L在运行过程中使用OSSemPendAbort ()函数而终止了任务H对信号量的的等待；任务H的OSSemPend ()函数返回OS_ERR_PEND_ABORT
    任务H进入就绪态，此时如果进行任务调度，由于任务H优先级大于任务L，那么任务H抢占CPU控制权而进入 运行态，任务L进入就绪态；
  - 输入
    - OS_SEM指针	操作的目标信号量
    - OS_OPT变量	
      - OS_OPT_PEND_ABORT_1	该信号量的任务挂起表中优先级最高的任务。取消等待该信号量
      - OS_OPT_PEND_ABORT_ALL	该信号量的任务挂起表中所有任务取消等待该信号量，即清空该信号量的任务挂起表
      - OS_OPT_PEND_NO_SCHED	执行完该函数后，不进行任务调度
    - OS_ERR指针	输入一个空白的OS_ERR变量，用于存储错误信息

- OSTaskSemPendAbort

  - 使能：OS_CFG_TASK_SEM_PEND_ABORT_EN 置1，位置：os_cfg.h

  - 输入

    - OS_TCB指针，要操作的目标任务信号量对应的任务的任务控制块的地址
    - OS_OPT变量
      - OS_OPT_POST_NONE         	正常执行
      - OS_OPT_POST_NO_SCHED	执行完该函数后，不进行任务调度
    - OS_ERR指针	输入一个空白的OS_ERR变量，用于存储错误信息

    

## 释放信号量

- OSSemPost

  - 任务A使用OSSemPost函数释放信号量x，此时
    如果系统中没有等待信号量x的任务，那么信号量x的计数值加1，任务A继续执行；
    如果系统中有等待信号量x的任务，那么这些等待信号量x的任务中优先级最高的任务B会获取信号量x
    信号量x的计数值先加1，再马上减1，相当于保持不变；
    这时任务A仍然处于运行状态，任务B由于获取了信号量x而从挂起态进入了就绪态；
    如果选择了OS_OPT_POST_NO_SCHED，那么就会进入任务调度，比较任务A和任务B的优先级：
    如果任务B>任务A，那么任务B就会抢占CPU而进入运行态，而任务A则是进入就绪态；
    如果任务A>任务B，那么保持原样；
  - 释放信号量是很随意的，任务可以通过调用该函数释放任意一个信号量；可以释放任意次数；
    如果随意释放，信号量的计数值就会趋于混乱，影响使用；
    所以一般规定：成功获取信号量的任务在执行完被锁代码后，必须释放该信号量；那么：
    - 信号量的计数值不会超过它被创建时设定的初始计数值；
      如果初始计数值设为1，那么就是二进制信号量；如果初始计数值大于1，那么就是计数型信号量；
    - 某个二进制信号量a的计数值为0，就可以推断出，某个任务获取了信号量a，该任务不是在运行态，就是在就绪态，而且它还没有执行完对应的被锁代码；在该任务执行完对应的被锁代码前，其他请求信号量a的任务都将进入等待态，就好比信号量a正被占用着，其他任务只能排队；
    - 某个初始计数值为3的技术型信号量的计数值为1，就可以推断出，有2个任务获取了信号量a，它们不是在运行态，就是在就绪态，而且还没有执行完对应的被锁代码； 	
  - 调用OS_TS_GET函数获得释放时刻的时间戳，保存在该信号量的TS成员中，以备OSMutexPend使用

  - 输入
    - OS_SEM指针	指定要释放的信号量的地址
      OS_OPT变量	
      - OS_OPT_POST_1	调用该函数，对应信号量计数值加1
      - OS_OPT_POST_ALL	调用该函数，对应信号量计数值加n，n为该信号量的任务挂起表中任务的数目
      - OS_OPT_POST_NO_SCHED	执行完该函数后，不进行任务调度，该选项可以和另外两个选项组合使用
    - OS_ERR指针	输入一个空白的OS_ERR变量，用于存储错误信息

-  OSTaskSemPost

  - 任务信号量只能被其它的任务(或中断服务程序)释放
  - 输入
    - OS_TCB指针	要释放的任务信号量 对应的 任务的 任务控制块 的地址
    - OS_OPT变量	
      - OS_OPT_POST_NONE 	正常执行
      - OS_OPT_POST_NO_SCHED	发布信号量之后不进行任务调度
    - OS_ERR指针	输入一个空白的OS_ERR变量，用于存储错误信息

- OS_SemDbgListRemove

  - 使能：OS_CFG_DBG_EN 置1，定义位置

## 访问共享资源

- 共享资源

  一个任务程序执行过程中，要在某个位置访问共享资源，就是在该位置插入一个共享资源函数，执行这个函数就是所谓的“访问共享资源”；共享资源其实就是一段程序，一般是封装成一个函数；即共享资源函数
  但是并不希望任务可以随意地访问共享资源，举例来说，某个共享资源函数表示打印机，访问该资源就是执行打印操作，但打印机只有一台，意味着任意时刻，该资源只能被一个任务访问；
  所以，为每一个共享资源配置一个唯一的信号量；该信号量的Ctr成员可以表示对应的资源是否空闲；
   	在共享资源函数前使用Pend函数请求这个信号量：
  Pend函数会查看该信号量的Ctr成员值，如果值是0，表明对应的共享资源不空闲，那么该任务进入等待态；
  如果值不等于0，表明可以访问该共享资源，任务继续执行，执行接下来的代码，即共享资源函数，即访问共享资源
  在共享资源函数内部的最后使用Post函数释放这个信号量：
  这一行为表明共享资源访问完毕，信号量的Ctr加1；
   	ISR只能使用OSSemPost()这一个函数，意味着中断服务是不能访问资源的，只有任务可以访问共享资源

  

- 使用二进制信号量

  为一个共享资源配置一个二进制信号量，表明在任意时刻，该资源只能被一个任务访问；
  使用函数OSSemCreate()初始化信号量时，将信号量的初始值设为1（对于二进制信号量，Ctr值不是1就是0）；
  该信号量的计数值只在1和0两者之间变化，1表示对应的资源正在被访问，0表示对应的资源是空闲的； 

- 使用计数型信号量

- 为一个共享资源配置一个计数型信号量，表明在任意时刻，该资源可以被多个任务访问；
  使用函数OSSemCreate()初始化信号量时，将信号量的初始值设为n（n≥1）；
  该信号量的计数值在[0,n]区间变化；任务请求该信号量时，只要其计数值大于0，那么该任务就能获得该信号量而执行下面的共享资源函数；

- 注意事项

  程序中可以使用任意多的信号量来保护各种资源。
  比如一个信号量用来访问一个共享的显示设备；另一个信号量用来访问一个共享的打印机；再另一个信号量用来共享一些数据结构；另一个信号量用来保护缓冲池 等等。
  不过一般不建议用信号量来访问I/O设备，也不用来访问存储单元。
  用信号量来处理简单的共享变量是小题大做：
  请求和释放信号量是很耗费时间的，甚至导致那些并不访问共享资源的高优先级任务也无法在第一时间被执行
  尽管关中断可能会带来一些间接成本，但用户仍可通过关中断、开中断来处理简单的共享变量从而提高整体的工作效率。
  例如两个任务共享一个32位的整型变量，一个任务给这个变量加1，另一个任务给这个变量清0.
  如果要求不管哪种操作，CPU都能在极端的事件内完成，那么显然是不会使用信号量来满足互斥访问条件的。 
  每个任务只需要在操作这个任务之前关中断，之后再开中断就可以了。然而，如果这个变量是浮点数，而相应的微处理器又没有硬件的浮点协处理器，则浮点运算的事件就会相当长，如此一来，关中断事件长了便会影响到中断延迟。这种情况下就要使用信号量了。
  在实时系统中，使用信号量还会导致一个严重的问题---优先级反转

  

- 优先级反转
  优先级反转只出现在使用基于优先级的可剥夺型内核时，是实时系统中经常要面对的一个问题：
  前面进行访问共享资源分析的时候，为什么没有出现优先级反转？那是因为前面的任务请求的都是刚被创建的信号量，也就是信号量被第一次使用。而一般的情况是一个信号量往往会被多次请求和使用。那么就会出现优先级反转
  假设优先级：任务H >任务M>任务L
  任务H和任务M处于等待态，任务L处于运行态
  任务L在运行时需要访问共享资源A，于是请求共享资源A对应的信号量a，请求获得回复，任务L仍然处于运行态，且执行共享资源程序。
  这时任务H等待的事件发生，由于它的优先级高，于是抢占了CPU进入运行态，任务L进入就绪态。
  任务H在运行时也要访问共享资源A，任务L是在执行共享资源A的程序的时候被打断的，现在仍处等待停滞的状态，同时还占有着共享资源A，信号量a处于无效状态，任务H的请求不能被立即回复而进入等待态。
  任务L继续运行，然而在任务L释放信号量a之前，任务M等待的事件又发生了。
  于是任务M又抢占了CPU。
  等任务M执行完毕，再轮到任务L执行，等任务L执行完共享资源A的程序并释放相应的信号量，这时才轮到任务H执行。
  也就是说任务H反而轮到了最后，更恶心的是只等任务L使用完任务资源A也就算了，中间还要等任务M执行完毕，这还算是不错的情况，如果有更多的想任务M这样优先级处于H和L之间的，在那个时候执行呢？那任务H要等到猴年马月！
  这又被成为无界优先级反转，因为任何一个在任务H和任务L 优先级之间的任务都可以延长任务H的等待时间。
  为了解决这一问题而引入了内核变量 –互斥型信号量



## 任务同步

- 任务同步

  可以发现，

  目标事件可能接着又出现了好几次，那么出现一次，信号量计数器的值都会加1。这时任务才执行了OSSemPend函数请求信号量a，这时系统中已经累计了很多个信号量a了（信号量a的计数器值的数值已经很大了），任务A可以根据这个信号量a的值做出相应的操作

  任务A的程序中，在某个位置插入Pend函数等待某个信号量；
  这一行为表明任务A要在该位置等待某个事件的发生，如果该事件已经发生，那么任务A继续执行下去，如果该事件没有发生，那么任务A就会在该位置等待，直到该事件发生；
  在任务B(或ISR)的程序中，在某个位置插入事件函数，在事件函数后使用Post函数释放对应的信号量：
  这一行为表明任务A等待的时间发生了，信号量的Ctr加1；
  在进行任务同步时，没有数据交换，把信号量用作一种发信号的机制

  ISR只能使用OSSemPost()这一个函数，意味着中断服务是不能等待事件的，只有任务可以等待事件

- 使用计数型信号量

  为一个事件配置一个唯一的计数型信号量
  使用函数OSSemCreate()初始化该信号量时，将信号量的初始值设为0，表示对应的事件还没有发生过；
  每当该信号量被释放一次，表示对应的事件发生一次，同时信号量的Ctr成员加1；
  Ctr记录了该事件发生的次数，这种功能称之为信用记录；
   初始化时，也可以将信号量计数值设为大于零的某个值，来表示出事情况下有多少个信号量可用。

- 单向同步

  任务A在执行过程中使用Pend函数请求信号量a，
  任务B(或ISR) 在执行过程中使用Post函数释放信号量a

- 双向同步

  任务A在执行过程中先使用Post函数释放信号量b，再使用Pend函数请求信号量a，
  任务B在执行过程中先使用Post函数释放信号量a，再使用Pend函数请求信号量b，
  至此，任务A和任务B各自内嵌的信号量A和B的计数器值都是1，我们称任务A和任务B同步了。
  接下来就看两个任务哪个优先级高就先执行哪个。
  双向同步只能用于任务和任务之间的同步；不能用于任务和ISR之间
  一般两个任务进行双向同步时，都会使用它们各自的任务信号量；




## 流量控制

任务间通信通常涉及到数据的传递，一个任务生产数据，而另一个任务消费数据。
然而，处理数据很花时间，消费者消费的速度也赶不上生产者生产的速度；
或者，如果有高优先级的任务抢占了消费者任务，那么生产者往消息队列放数据就有可能溢出。
解决这个问题的一种办法就是在数据传递的过程中加上流量控制。

使用一个计数型信号量，其初始值为允许生产者发布的消息数目。如果消费者最多只能容纳10则消息，那么这个计数型信号量的初始值是10。
生产者在发布消息前必须先获得信号量。而消费者正在等待消息，一旦处理完一则消息，便释放信号量。

结合任务的内嵌消息队列和任务内嵌信号量，可以很容易实现上述的流量控制。
注意建立任务后必须立即调用OSTaskSemSet()来设置任务内建信号量的值，初始值应该和任务内建的消息队列所能容纳的消息数目一致。



# 互斥型信号量

- 使能	OS_CFG_Mutex_EN置1，位置：os.h

- 定义	互斥型信号量是一个OS_MUTEX类型的结构变量，定义位置：os.h

- 状态	

  - 虚无状态,还没有被创建
  - 存在状态，互斥型信号量被创建后，只有占用 和 未占用 两个状态，所以互斥型信号量是一个二进制的信号量
    一个任务只能占用一个互斥型信号量
    - 占用：OwnerTCBPtr=某个任务的任务控制块地址；
    - 未占用	OwnerTCBPtr=0

- 嵌套深度

  使用OS_NESTING_CTR类型变量表示一个互斥型信号量的嵌套深度，
  一个互斥型信号量刚被创建时，嵌套深度=0；
  未占用占用 ，嵌套深度从01
  一个任务在已经占用某个互斥型信号量的情况下可以再次使用OSMutexPend()函数请求该互斥型信号量，如果请求成功，那么该互斥型信号量的嵌套深度加1；嵌套深度最多叠加到250
  一个任务使用OSMutexPost()函数释放它所占用的互斥型信号量，那么该互斥型信号量的嵌套深度减1；
  只有当嵌套深度等于0时，该互斥型信号量才算被真正释放，其他任务才能获取该互斥型信号量

- OS_MUTEX

  - Type，OS_OBJ_TYPE变量，Type=OS_OBJ_TYPE_MUTEX，表明该结构类型变量表示互斥型信号量
  - NamePtr	CPU_CHAR指针	内核对象的名称，字符串数组的首地址 
  - PendList	OS_PEND_LIST变量	内核对象的任务挂起表
  - DbgPrevPtr	OS_MUTEX指针
  - DbgNextPtr	OS_MUTEX指针
  - DbgNamePtr	CPU_CHAR指针
  - OwnerTCBPtr	OS_TCB指针	此刻占用这个互斥型信号量的任务的任务控制块的地址，0：表示该互斥型信号量还没有被占用
  - OwnerOriginalPrio	OS_PRIO指针	此刻占用这个互斥型信号量的任务的优先级
    注：如果为避免优先级反转而临时提高任务的优先级，那么这就是占有之前的优先级；
  - OwnerNestingCtr	OS_NESTING_CTR变量，嵌套深度 
    使用OSMutexCreate()函数创建互斥型信号量时，嵌套深度初始化为0
    某个任务可以对同一个互斥型信号量使用多次OSMutexPend函数请求，每次函数执行成功，嵌套深度加1，最大取值250；
    当嵌套深度不为0时可以使用OSMutexPost释放，每次释放，嵌套深度减1；
    只要嵌套深度不为0，该任务始终占有这个互斥型信号量，直到完全释放(嵌套深度=0)
  - TS	CPU_TS变量	该互斥型信号量上一次被释放的时刻，单位：时钟节拍

- OSMutexCreate

  初始化成员OwnerTCBPtr=0，OwnerNestingCtr=0；
  互斥型信号量刚被创建时处于有效状态；嵌套深度为0；
  互斥型信号量状态转变：虚无状态存在状态
  本函数调用OS_MutexInit()函数

  - 输入
    - OS_MUTEX指针	传递一个空白的OS_MUTEX变量的地址
    - CPU_CHAR 指针	该互斥型信号量的名称 ，字符串数组的首地址 
    - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息

- OSMutexDel

  - 使能：OS_CFG_MUTEX_DEL_EN 置1，位置：os_cfg.h
    互斥型信号量状态转变：存在状态虚无状态
    本函数执行时会调用OS_MutexClr()函数，OS_MutexClr实现清空该信号量的所有成员
  - 输入
    - OS_MUTEX指针	要操作的目标互斥信号量的地址
    - OS_OPT变量
      - OS_OPT_DEL_NO_PEND 	
      - OS_OPT_DEL_ALWAYS 		

## 等待互斥型信号量

- OSMutexPend

  - 使用
    - 任务H处于运行状态，并且使用该函数：
    - 如果请求的互斥型信号量处于未占用状态：那么任务H不必等待，直接继续执行，同时该互斥型信号量
      OwnerTCBPtr成员更新为任务A的任务控制块地址；OwnerNestingCtr成员更新为1；
    - 如果请求的互斥型信号量已经被任务L占用的，且任务L的优先级较低，那么任务L的优先级会被临时性提高到和任务H一样，但该互斥型信号量的OwnerOriginalPrio成员记录好了任务L原来的优先级；
      如果OPT=OS_OPT_PEND_NON_BLOCKING，那么任务H进入等待态，任务L进入运行态
      任务L运行完毕释放互斥型信号量，并恢复优先级；任务H获得该互斥型信号量，进入运行态；
      OwnerTCBPtr成员更新为任务H的任务控制块地址；OwnerNestingCtr成员更新为1；
    - 如果请求的互斥型信号量已经是被任务H占用了，
      那么仅仅将 OwnerNestingCtr成员加1；任务H继续执行，函数返回OS_ERR_MUTEX_OWNER
    - 调用OS_MutexDbgListAdd ()函数：
      使能：OS_CFG_DBG_EN置1，定义位置：
      如果将调用该函数的任务要进入等待状态，那么该函数就会调用OS_MutexDbgListAdd ()函数，将该任务插入到该信号量的任务挂起表中；
  - 输入	
    - OS_MUTEX指针	指定好了所等待的互斥型信号量的地址
    - OS_TICK变量	等待超时时间timeout，单位：时钟节拍；仅在OS_OPT_PEND_BLOCKING模式下有效
      timeout = 0：表示没有超时时间，任务会一直等下去
      从调用这个函数开始，经过等待超时时间，如果所等待的信号量还没有释放，
      那么这个任务会取消等待该信号量，同时函数返回超时的错误代码
    - OS_OPT变量	任务调用该函数的时刻，如果所等待的信号量处于无效状态
      - OS_OPT_PEND_BLOCKING	任务进入等待态，直到信号量被释放或超时
      - OS_OPT_PEND_NON_BLOCKING	任务不会等待，函数返回OS_ERR_PEND_WOULD_BLOCK
    - CPU_TS指针	输入一个空白的CPU_TS类型变量的地址，所等待的信号量一旦被释放，那么该信号量的TS成员就会更新，记录该信号量释放的时刻，程序将该时刻传递给该CPU_TS变量；用户获取任务继续执行时刻，就可以算出信号量从被释放到被接收的时间间隔。 
    - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息

- OSMutexPendAbort

  - 使用

    使能：OS_CFG_MUTEX_PEND_ABORT_EN 置1，位置：os_cfg.h 	

    任务H运行过程中调用OSMutexPend()函数后进入等待态；
    就绪态中优先级最高的任务L进如运行态，任务L在运行过程中使用OSMutexPendAbort()函数而终止了任务H对信号量的的等待；任务H的OSMutexPend()函数返回OS_ERR_PEND_ABORT
    任务H进入就绪态，此时如果进行任务调度，由于任务H优先级大于任务L，那么任务H抢占CPU控制权而进入 运行态，任务L进入就绪态；

  - 输入

    - OS_MUTEX指针，要操作的目标互斥型信号量的地址
    - OS_OPT变量
      - OS_OPT_PEND_ABORT_1	该信号量的任务挂起表中优先级最高的任务取消等待该信号量
      - OS_OPT_PEND_ABORT_ALL	该信号量的任务挂起表中所有任务取消等待该信号量，即清空该信号量的任务挂起表

## 释放互斥型信号量

- OSMutexPost
  - 使用
    - 任务A调用本函数释放互斥型信号量，该互斥型信号量的OwnerNestingCtr成员减1，这时
    - 如果OwnerNestingCtr=0，说明该互斥型信号量被完全释放，OwnerTCBPtr成员更新为NULL；
      如果OwnerNestingCtr≠0，说明该互斥型信号量没有真正释放，OwnerTCBPtr仍旧是任务A的任务控制块的地址，函数返回OS_ERR_MUTEX_NESTING；
    - 每当某个互斥型信号量被完全释放，都会执行下述的操作；
      对于之前占有该互斥型信号量的的任务： 如果之前临时提高了任务A的优先级，那么此时任务A就会恢复到原来的优先级
    - 调用OS_MutexDbgListRemove函数，
      使能：OS_CFG_DBG_EN置1，位置：
    - 调用OS_TS_GET函数获得释放时刻的时间戳，保存在该互斥型信号量的TS成员中，以备OSMutexPend使用
  - 输入
    - OS_MUTEX指针：指定要释放的互斥型信号量的地址
    - OS_OPT
      - OS_OPT_POST_NONE 	正常执行
      - OS_OPT_POST_NO_SCHED	调用该函数之后不进行任务调度

## 访问共享资源	
如果没有任务对共享资源的访问有截止时间，那么普通信号量就可以代替互斥型信号量反
之则必须使用互斥型信号量。因为前者会造成无界优先级反转，而后者不会；

互斥型信号量只在被占用和未被占用两个状态间变化，对应的是成员OwnerTCBPtr在有值和空值两个状态间变化，
实现的效果是共享资源在同一时刻只能被一个任务调用。
这与普通的二进制信号量并无二致；
这就是使用二进制互斥型信号量访问共享资源

关于“不是第一次被访问”：
无非两种情况：
一个高优先级的任务运行时想要访问共享资源，但它不是第一个访问这个共享资源的任务
一个低优先级的任务在此之前已经访问过该共享资源，且由于它的优先级低，在访问共享资源的时候被高优先级的任务抢占了CPU
那么这个低优先级任务的优先级将被提升至与那个高优先级任务的一样

一个低优先级的任务运行时想要访问共享资源，但它不是第一个访问这个共享资源的任务
一个高优先级的任务在此之前已经访问过该共享资源，且由于某些原因，在访问共享资源的时候进入了等待态。
那么这个低优先级任务只能进入等待态，没有任何办法。

- 互斥型信号量第一次被请求访问（且没有嵌套使用）
  - 创建互斥型信号量a	
  - 1.创建一个OS_Mutex类型的变量作为互斥型信号量
    2.使用函数OSMutexCreate()
    这时互斥型信号量a的OwnerTCBPtr被初始化清0，互斥型信号量a处于有效状态
  - 任务A进入运行态	
  - 任务A请求资源	任务A调用OSMutexPend()函数
  - 任务A获取共享资源	因为前面创建互斥型信号量a时，被创建后的初始状态就是有效的。
    这个时候任务A通过调用OSMutexPend()请求互斥型信号量a，任务A进入等待态后，请求会立即得到响应，任务A马上从等待态进入就绪态，任务A的优先级是最高的，立刻发生任务切换，任务A进入运行态，继续执行接下来的任务代码。，后续代码中有其需求的共享资源。所谓的共享资源，前面所过，其实就是一段程序。一般是封装成一个函数。
    我们在任务中，在这段代码前面设了一道坎，必须等待某个互斥型信号量，才能继续执行。
  - 任务A访问共享资源	任务A在调用OSMutexPend()函数 到 调用OSMutexPost()函数 这段时间内，是本任务访问共享资源的时间（正在执行共享资源的代码）。
    互斥型信号量a的OwnerTCBPtr始终等于调用OSMutexPend()函数的任务A的任务控制块的地址，
    即互斥型信号量a是被占用着的。
    互斥型信号量a的OwnerNestingCtr的值加1
  - 任务B进入运形态	任务B由于其高优先级它夺取了CPU的控制权，然后想要访问相同的共享资源，那么任务B也得请求互斥型信号量a，但显然是得不到回复的，因为此时互斥型信号量a是无效的，那么任务B只能进入等待态，那么原来的任务又回到运行态，继续运行，直到访问共享资源完毕。
  - 任务A释放互斥型信号量	任务A访问共享资源完毕后，调用OSMutexPost()来释放互斥型信号量a。
    互斥型信号量a的OwnerTCBPtr清空
    互斥型信号量a的OwnerNestingCtr的值减1变为0；
    因为没有嵌套使用，所以OwnerNestingCtr的值只在1和0之间变化
  - 任务B获取共享资源	这个时候，正处于等待态的任务B对互斥型信号量a的请求得到回应，它就可以访问共享资源了。（假设此事有一个一个任务即任务B在请求互斥型信号量a）
- 假设下面这种情况（继续前面章节优先级反转的例子：）
  优先级：任务H >任务M>任务L
- 互斥型信号量不是第一次被请求访问（没有嵌套使用）
  - 创建互斥型信号量a	
    1.创建一个OS_Mutex类型的变量作为互斥型信号量
    2.使用函数OSMutexCreate()
    这时互斥型信号量a的OwnerTCBPtr被初始化清0，互斥型信号量a处于有效状态
  - 任务L进入运行态	假设这个时候，任务H和任务M处于等待态，任务L处于运行态
  - 任务L请求资源	任务L在运行时需要访问共享资源A，于是使用OSMutexPend()函数请求共享资源A对应的信号量a
  - 任务L获取共享资源	因为前面创建互斥型信号量a时，被创建后的初始状态就是有效的。
    任务L通过调用OSMutexPend()请求互斥型信号量a，任务进入等待态后，请求会立即得到响应，任务L马上从等待态进入就绪态，任务L的优先级比正在运行的任务的高，立刻发生任务切换，任务L会再进入运行态，继续执行接下来的任务代码。，后续代码中有其需求的共享资源。
  - 任务L访问共享资源	在任务L调用OSMutexPend()函数 到 调用OSMutexPost()函数 这段时间内，是任务L访问共享资源的时间（正在执行共享资源的代码）。
    互斥型信号量a的OwnerTCBPtr始终等于任务L的任务控制块的地址，即互斥型信号量a被任务L占用着。
    互斥型信号量a的OwnerNestingCtr的值从0变为1
  - 任务H进入运行态	任务H等待的事件发生，由于它的优先级高，于是抢占了CPU进入运行态，任务L进入就绪态。
  - 任务H请求资源	任务H在运行时需要访问共享资源A，于是使用OSMutexPend()函数请求共享资源A对应的信号量a
    但显然是得不到回复的，任务L是在执行共享资源A的程序的时候被打断的，现在仍处等待停滞的状态，同时还占有着共享资源A，互斥型信号量a处于无效状态，任务H的请求不能被立即回复而进入等待态。但是！
    具有高优先级的任务H运行时想要访问共享资源，那么正处于等待态的占有该共享资源的低优先级任务L的优先级将被提升至与任务H的一样
  - 任务L进入运行态	任务L重新获得CPU控制权，继续执行共享资源程序
  - 任务M等待的事件发生了	但是任务L的优先级高于任务M，所以任务M还是得继续等
  - 任务L释放互斥型信号量	任务L访问共享资源完毕后，调用OSMutexPost()来释放互斥型信号量a。
    一旦任务L释放了互斥型信号量a，任务L的优先级会降到原来的水平
    互斥型信号量a的OwnerTCBPtr清空
    互斥型信号量a的OwnerNestingCtr的值减1变为0；
    因为没有嵌套使用，所以OwnerNestingCtr的值只1和0之间变化，前面任务L调用OSMutexPost()后OwnerNestingCtr的值变为0；
  - 任务H获取共享资源	这个时候，正处于等待态的任务H又成为了优先级最高的任务。而且互斥型信号量a也正处于有效状态。
    对互斥型信号量a的请求得到回应，它就可以访问共享资源了。
    （假设此事有一个一个任务即任务B在请求互斥型信号量a）
  - 任务H访问共享资源	任务H和任务L不同，任务H使用OSMutexPend()函数后并没有立即获得共享资源，
    所以任务H访问共享资源的时间（正在执行共享资源的代码）是从对互斥型信号量a的请求得到回应 到
    调用OSMutexPost()函数 这段时间。
    互斥型信号量a的OwnerTCBPtr始终等于任务H的任务控制块的地址
    互斥型信号量a的OwnerNestingCtr的值又变为1
     	任务H释放互斥型信号量	任务H访问共享资源完毕后，调用OSMutexPost()来释放互斥型信号量a。
    互斥型信号量a的OwnerNestingCtr的值减1变为0；
    因为没有嵌套使用，所以OwnerNestingCtr的值只1和0之间变化
- 总结：
  任务H利用了任务L，它让任务L安安心心的执行完共享资源程序（当然如果此时出现了不任务H的优先级还要高的任务那也没有办法，本来优先级高的任务就应该先执行）
  当然也仅仅是允许L执行完共享资源程序这一段，一旦互斥信号量被释放，任务L的优先级又降回去了，那么任务H就可以获得信号量进入运行态了。
  总结下来，任务H只牺牲了“任务L执行完共享资源程序”这点成本，但能够屏蔽众多“任务M”的打扰。
  显然任务H洗完任务L访问共享资源的速度越快越好，释放互斥型信号量越早越好；



- 嵌套使用

  - 创建互斥型信号量a	

  - 1.创建一个OS_Mutex类型的变量作为互斥型信号量
    2.使用函数OSMutexCreate()
    这时互斥型信号量a的OwnerTCBPtr被初始化清0，互斥型信号量a处于有效状态

  - 任务进入运行态	

  - 任务请求资源	任务在运行时需要访问共享资源，于是使用OSMutexPend()函数请求共享资源对应的信号量a

  - 任务获取共享资源	因为前面创建互斥型信号量a时，被创建后的初始状态就是有效的。
    任务通过调用OSMutexPend()请求互斥型信号量a，任务进入等待态后，请求会立即得到响应，任务马上从等待态进入就绪态，这个任务的优先级比正在运行的任务的高，立即发生任务切换，该任务会再进入运行态，继续执行接下来的任务代码，后续代码中有其需求的共享资源。

  - 任务访问共享资源A	任务调用OSMutexPend()函数得到回复后就开始访问共享资源（执行共享资源A的代码）。
    互斥型信号量a的OwnerTCBPtr始终等于任务A的任务控制块的地址，即互斥型信号量a被任务占用着。
    互斥型信号量a的OwnerNestingCtr的值从0变为1（嵌套1次）

  - 任务访问共享资源B	任务在执行共享资源A的代码的过程中又调用OSMutexPend()函数得到回复后就开始访问共享资源B（执行共享资源B的代码）。
    在执行共享资源A的过程中，任务对于互斥型信号a是持续拥有的，依据是：
    在这个过程中任务通过调用OSMutexPend()请求互斥型信号a时，如果检查互斥信号量a的OwnerTCBPtr的值，肯定是任务的任务控制块的地址。因为要清除互斥信号量a的OwnerTCBPtr的值，只能通过OSMutexPost()函数，之前一次也没有用过OSMutexPost()函数，互斥信号量a的OwnerTCBPtr的值，肯定仍旧是任务的任务控制块的地址。
    更何况在嵌套使用的情况下，即使使用了OSMutexPost()函数，也不一定能清除互斥信号量a的OwnerTCBPtr的值（后面会讲）
    互斥型信号量a的OwnerTCBPtr始终等于任务的任务控制块的地址，即互斥型信号量a被任务占用着。
    互斥型信号量a的OwnerNestingCtr的值从1变为2（嵌套2次）

  - 任务访问共享资源C	任务在执行共享资源B的代码的过程中又调用OSMutexPend()函数得到回复后就开始访问共享资源C（执行共享资源C的代码）。

  - 互斥型信号量a的OwnerTCBPtr始终等于任务的任务控制块的地址，即互斥型信号量a被任务占用着。
    互斥型信号量a的OwnerNestingCtr的值从2变为3（嵌套3次）

  - 任务释放互斥型信号量	任务访问共享资源C完毕后，调用OSMutexPost()想要来释放互斥型信号量a。
    但是这仅仅是在嵌套中释放，没有真正释放互斥型信号量a，如果这个时候有其他任务请求互斥型信号量a是得不到恢复的。
    互斥型信号量a的OwnerTCBPtr始终等于任务的任务控制块的地址，即互斥型信号量a被任务占用着
    互斥型信号量a的OwnerNestingCtr的值减3变为2；
    接下来继续执行共享资源B剩下的程序

  - 任务释放互斥型信号量	任务访问共享资源B完毕后，调用OSMutexPost()想要来释放互斥型信号量a。
    但是这仅仅是在嵌套中释放，没有真正释放互斥型信号量a，如果这个时候有其他任务请求互斥型信号量a是得不到恢复的。
    互斥型信号量a的OwnerTCBPtr始终等于任务的任务控制块的地址，即互斥型信号量a被任务占用着
    互斥型信号量a的OwnerNestingCtr的值减2变为1；
    接下来继续执行共享资源A剩下的程序

  - 任务释放互斥型信号量	任务访问共享资源A完毕后，调用OSMutexPost()想要来释放互斥型信号量a。
    互斥型信号量a的OwnerNestingCtr的值减1变为0；
    这个时候才真正释放互斥型信号量a
    互斥型信号量a的OwnerTCBPtr清空

  - 任务每次调用OSMutexPend()函数都要检查函数的返回值(其他内核调用也是这样)，以此来保证OSMutexPend()函数返回是因为程序已经真正获得了该互斥型信号量，而并不是因为互斥型信号量被删除了，也不是因为有其他任务调用了OSMutexPendAbort()函数而终止了对该互斥型信号量的的等待；

  - 总结：
    无论是共享资源A还是共享资源B，还是共享资源C，都只是一段程序代码，我们把它们都看成一个函数。
    显然函数C被包含于函数B，函数B被包含于被包含于函数A中。
    所以事实上，本来就不应该存在什么信号量的嵌套使用，因为在共享资源A中请求了互斥型信号量a是没有意义的，肯定得到允许。
    **！！所以其实至始至终只是一直在执行共享资源A的程序代码而已！！**

    那为什么还要嵌套呢？
    我们也知道也正因为共享资源程序是一个个函数，我们在定义这些函数的时候，并不知道它们会不会被嵌套使用，所以都是按规矩办事，只要是想访问共享资源，就得是用OSMutexPend()函数请求一个信号量。而一旦请求了信号量并获得允许，那就得做相应的信号量释放。

    **所以任务只有释放相同的次数才能真正释放这个互斥型信号量。互斥型信号量的成员OwnerNestingCtr 记录了嵌套的次数。**



 一般来说不要再临界区内调用其他函数。所有的互斥型信号量的服务函数必须在源代码的叶节点(比如说直接操作硬件的底层驱动代码或者那些可重入的函数库)处调用



## 死锁（抱死）
显然互斥型信号量在任务访问共享资源的时候相比于信号量有着明显的优势。
所以一般访问共享资源我们就选择使用互斥型信号量，而普通的信号量更多的适用于任务同步
但如果一个任务在其执行过程中先后使用了多个互斥型信号量（不是同时），那就可能出现死锁（抱死）状态：

死锁（抱死）
低优先级任务L成功获取互斥型信号量a，执行互斥型信号量a对应的资源A；
在任务L访问资源A时，高优先级任务H抢占CPU，H在运行过程中成功获取互斥型信号量b，执行对应的资源B；
在任务H访问资源B的过程中，请求互斥型信号量a，但其处于被任务L占用的状态；于是任务L临时提高优先级而进入运行性状态，继续访问资源A；
在任务L继续访问资源A的过程中，请求互斥型信号量b，但其处于被H占用的状态，于是L进入等待态；
但此时任务H也在等待态，等待正被L占据的互斥型信号量a
两个任务无限制地等待对方控制的资源，这就是死锁(抱死)

解决办法
通过上述的例子总结出现死锁的原因：一个任务成功获取了一个互斥型信号量后，在释放该互斥型信号量之前又请求另外一个互斥型信号量，这时就有可能发生死锁，所以：要求任务访问完毕一个互斥型信号量对应资源后，再访问另一个资源；

如果还是得在释放一个互斥型信号量之前请求另外一个互斥型信号量，那么就要求用相同的顺序申请多个资源
如上例中任务L先请求互斥信号量a，再请求互斥信号量b的，那么对于任务H，它如果请求的资源和L一样，那么顺序也得和L一样，也是先请求a再请求b
每个请求互斥型信号量时都设定超时时间

这是一个好习惯，是本来就因该这么做的。但是，它其实没有解决问题，只是避开了问题，系统返回超时的任务代码，任务L和任务H都没有得到顺利的执行。另外同样的死锁问题还可能会出现。

## 使用临界段代码独占共享资源
很多硬件如打印机、磁带机等，都属于临界资源
临界段代码，也叫临界区，是指那些必须完整连续运行，不可被打断的代码段。
显然，为了满足要求，在临界段代码执行的时候，要避免发生中断。

举个时钟模块TimeOfDay()的例子：
这个任务的功能是用来获取当前时间。
注：TimeOfDay()是一个任务，同时也是一个函数，一段程序代码，一旦调用这个函数，就会执行一段代码，把当前的时、分、秒 数值传递给全局变量 Hours、Minutes、Seconds
想要获取当前时间，就调用这个函数（执行这个任务），但并不是说立刻就能得到结果，程序仍然还是一步一步执行的！
如果执行这个时间模块任务时发生中断，在执行这一系列与这个中断相关的程序 的时候，TimeOfDay()任务一直处于停滞状态，
等这一系列与这个中断相关的程序 执行完毕，系统再回到TimeOfDay()之前中断的地方继续往下执行，但最终得到的时间结果肯定是不准的。
所以我希望我在执行TimeOfDay()的时候，让我连续执行完毕，返回结果。

把上述例子中的 Hours、Minutes、Seconds 称为共享资源

总结下来有以下4中方式访问共享资源：
1.关中断、开中断	
2.给调度器上锁、解锁	
3.信号量	
4.互斥信号量	这是最好的方式



导致临界段代码长度增加的情况
情况1：多个任务具有相同的优先级
情况2：事件标志组
情况3：同时等待多个内核对象
情况4：广播方式发送消息或信号量



# 消息队列

用户可以使用动态分配的存储块，或者也可以传递一个指向全局变量、全局数据结构、全局数组、或者函数的指针。
消息队列是一种由用户程序分配的内核对象。可以分配任意数量，受RAM容量的限制。
任务可以使用下列所有函数，而ISR只能使用OSQPost()这一个

系统在最开始就为所有的消息都分配好了存储空间，这些消息在没有被使用时，都在缓冲池中，即都是空闲的，但仍然占据着存储空间，有各自的地址。即MsgPtr

- 使能	OS_CFG_Q_EN置1，位置：os_cfg.h

- 定义	消息队列就是一个OS_Q变量

  - 一个消息队列 对应 一个OS_Q变量 对应一个 OS_MSG_Q 变量 对应 *.NbrEntriesSize个消息
    创建一个消息队列后，消息也随之被创建，一个消息队列对应*.NbrEntriesSize 个消息；
    这些刚创建的消息都是空闲的，我称它们为无效消息；
    每一个消息(不管有效还是无效)都在RAM中占据了一块存储空间，都有一个确定的地址，我称之为消息地址；
    进行消息传递时，传递的数据称为消息数据；消息传递是引用传递而不是值传递，就是说传递的是消息数据的地址，而不是消息数据；
    一定要区分：消息数据的地址和消息地址两个地址不同！！

  - 消息数据是在其他地方创建的，要传递消息时，将消息数据的地址填充到某个消息队列的某个消息中；
    所以在消息传递时必须要保证这个消息数据的地址对于发送方和接收方而言都是可见的，并且是指向同一个存储单元
    另外，发布方一旦发出一个消息，就不能再修改这个消息对应的的消息数据；
    要在消息队列中选择一个消息，在该消息中填充消息数据，然后再把这个消息发送出去



- 消息队列	OS_Q	
  - Type	OS_OBJ_TYPE变量	Type = OS_OBJ_TYPE_Q，表示该内核对象是消息队列
  - NamePtr	CPU_CHAR指针	内核对象的名称，字符串数组的首地址
  - PendList	OS_PEND_LIST变量	该消息队列的任务挂起表
  - DbgPrevPtr	OS_Q指针
  - DbgNextPtr	OS_Q 指针
  - DbgNamePtr	CPU_CHAR指针
  - MsgQ	OS_MSG_Q变量	消息队列的本体，见下一张表格
- 消息队列本体	OS_MSG_Q
  - InPtr	OS_MSG指针	当要给该消息队列的某个消息填充消息数据的地址时；
    所选择的消息的地址 = *.InPtr后一个地址
  - OutPtr	OS_MSG指针	该消息队列要释放某个消息时；
    所选择的消息的地址
  - NbrEntriesSize	OS_MSG_QTY变量	该消息队列最多能容纳的消息数目
  - NbrEntries	OS_MSG_QTY变量	该消息队列当前容纳的消息的数目
    当NbrEntries= NbrEntriesSize时，表示这个消息队列已经装满这时程序再向这个消息队列发布消息，则这个消息无效被丢弃
  - NbrEntriesMax	OS_MSG_QTY变量	该消息队列中，有效消息的数目曾达到的最大值
- 消息	OS_MSG	
  - NextPtr	OS_MSG指针
    - 在消息队列中，本消息是一个无效消息	NextPtr表示该消息的下一个无效消息的地址
    - 在消息队列中，本消息是一个有效消息	NextPtr表示该消息的下一个有效消息的地址
    - MsgPtr	void指针	消息数据的地址；
    - MsgSize	OS_MSG_SIZE变量	消息数据的长度
    - MsgTS	CPU_TS变量	记录本消息上一次发送时刻的时间戳
- 消息缓冲池	OS_MSG_POOL	
  - NextPtr	OS_MSG指针	指向空闲的OS_MSG链表
    NbrFree	OS_MSG_QTY变量	当前系统中无效消息的总数
    NbrUsed	OS_MSG_QTY变量	当前系统中有效消息的总数
    NbrUsedMax	OS_MSG_QTY变量	记录有效消息的数目曾达到的最大值
- 任务消息队列
  - 使能：OS_CFG_TASK_Q_EN置1，位置：os_cfg.h
  - 多个任务等待同一个消息队列的情况很少见。
    所以在μC/OS–III中每一个任务都有其内建的消息队列，用户可以不用通过外部的消息队列而直接向任务发布消息；
    任务消息队列的作用与普通消息队列的一样，但普通消息队列是所有任务都可以申请它的消息，而任务消息队列的消息却只能给一个特定任务使用，也就是说任务消息队列是一个任务本身的属性，但其他任务都可以给这个任务发送任务消息。
    在任务A中使用下面的这些任务信号服务函数。那么
    对任务信号量的操作函数定义在文件os_task.h
    使用这些函数需要配置os_cfg.h中的常量 OS_CFG_SEM_EN=1
  - 在创建任务时任务消息队列会被自动创建，创建后为空，消息队列中其中没有消息。 
    所以不会有信号量初始化函数和任务信号量删除函数。
  - 在任务A中使用OSTaskQPend()函数请求任务A的内嵌消息队列
  - 在任务A中使用OSTaskQPost()函数存储消息至任务B的内嵌消息队列，调用OSTaskQPost()函数时需要将任务B的任务控制块的地址传递给OSTaskQPost()函数。
    任务A的信号量可以由其它任务使用OSTaskQPost发出。


消息缓冲池 管理整个系统中所有的消息队列
消息缓冲池 管理整个系统中所有的消息


OSTaskQFlush()	清空消息队列
OSTaskPend()	等待一个消息队列
OSTaskPendAbort	取消等待
OSTaskPost	向某个消息队列发布一则消息


显然，发布方和接收方需要对数据的内容和含义达成约定。换句话说，消息的接收方需要知道所受到的消息的含义才能对其进行处理。举个例子，一个以太网控制器收到一个数据包并将指向数据包的指针发布给一个任务，那么该任务就需要直到如何来处理数据包。
消息的内容必须一直保持可见性（即代表消息的变量必须在接收消息的任务代码范围内有效），因为发布数据采用的是引用传递，是指针传递而不是值传递。也就是说，发布的数据本身不产生拷贝。

用户可以使用动态分配的存储块，或者也可以传递一个指向全局变量、全局数据结构、全局数组、或者函数的指针。

消息队列是一种由用户程序分配的内核对象。可以分配任意数量，受RAM容量的限制。

任务可以使用下列所有函数，而ISR只能使用OSQPost()这一个

任务可以将消息存储到消息队列中，也可以从消息队列读取信息数据；
可见两个任务可以使用消息队列来相互传递信息；
任务想要收发消息的时候都得通过消息队列；

一个任务或者中断服务程序在执行的时候可能需要和另一个任务交流信息，这个信息传递的过程称为任务间的通信。
任务间的信息传递可以通过两种途径实现：
1.全局变量
2.发布消息

1.使用全局变量的时候，每一个任务或者中断服务程序都必须保证其对变量的独占访问。
如果有中断服务程序参与，那唯一能保证对共享变量独占访问的方法就是关中断。
如果只是两个任务之间共享数据，那么保证独占访问的方法有多种：关中断、给调度器上锁、使用信号量或者使用互斥型信号量（最推荐的方法）。
请注意，任务想要和中断服务程序通信，只能通过全局变量。在这种情况下，任务并不知道全局变量在何时会被中断服务程序修改，除非中断服务程序通知任务，或者任务定期查询全局变量的值。

2.使用消息的时候，消息可以通过消息队列作为中介发布给任务，也可以直接发布给任务，因为在系统中，每一个任务都有其内嵌的消息队列（见“任务消息队列”章节）。
当有多个任务在等待消息的时候，可以使用外部的消息队列；而如果只有一个任务需要对接收的数据进行处理，则应该使用任务内嵌的消息队列。

**从消息队列释放消息的时候，每次使用OSQ_Pend()函数，释放的是消息队列的开头的那个消息，使用完后，这个消息就会消失，下一个消息成为新的“开头消息”。**
**如果使用OSQ_Pend()函数的时候，消息队列中已经没有消息了，那么这个任务就会进入等待态。**
**所以任务是只能指定请求哪个消息队列的开头消息，是不能任意从消息队列中挑选的。**

**将消息存储到消息队列时，有两种存储方法，先进先出（FIFO）的方式和LIFO（后进先出）的方式。**
**FIFO→消息存储在消息队列的开头，这是“进”的方式，因为“出”的方式总是出开头的那个消息，所以实现的效果就是先进先出。**
**LIFO→消息存储在消息队列的末尾，这是“进”的方式，因为“出”的方式总是出开头的那个消息，所以实现的效果就是后进先出。**

当任务或者ISR需要向一个任务发布一则紧急消息的时候，后进先出的机制就非常有用了。
使用后进先出的方式，发布的消息会绕过所有其他已经位于消息队列的消息而最先传递给任务。消息队列的容量可以在运行的时候配置。
缓冲池可容纳的消息（OS_MSG）的总数（即整个系统中可用的消息（OS_MSG）的总数）为OS_CFG_MSG_POOL_SIZE。
OS_CFG_MSG_POOL_SIZE定义在cfg_app.h文件
可见创建消息的数目是受限制的。
系统在最开始就为所有的消息都分配好了存储空间，这些消息都是空闲的，即占据了存储空间，但还没有被用户使用。
在缓冲池中，所有的消息（OS_MSG）被连成一个单向链表


- OSQCreate

  本函数执行时调用OS_QInit()函数，初始化消息队列的各个成员的值

  - 输入	
    - OS_Q指针	消息队列的地址
    - CPU_CHAR指针	消息队列的名称 ，字符串数组的首地址
    - OS_MSG_QTY变量	指定消息队列可以包含的消息的最大数目，必须为非零数值。
    - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息

- OSQDel	

  - 使能：OS_CFG_Q_DEL_EN 置1，位置os_cfg.h
    本函数执行时调用OS_QClr()函数，清零消息队列的所有成员
  - 输入	
    - OS_Q指针	要删除的消息队列的地址
    - OS_OPT
      - OS_OPT_DEL_NO_PEND
      - OS_OPT_DEL_ALWAYS
    - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息

- OSQFlush	

  - 使用：#if OS_CFG_Q_FLUSH_EN > 0u
    清空消息队列
  - 输入	
    - OS_Q指针
    - OS_ERR指针

- OSTaskQFlush	

  - 输入	
    - OS_TCB指针	
    - OS_ERR指针	
  - 使用	#if OS_CFG_TASK_Q_EN > 0u

- OS_QDbgListAdd	

  - 输入	
    - OS_Q指针	
  - 使用	#if OS_CFG_DBG_EN > 0u

- OS_QDbgListRemove	

  - 输入	OS_Q指针	
  - 使用	#if OS_CFG_DBG_EN > 0u


## 等待消息队列

- OSQPend	输入	OS_Q指针	指定好要等待的消息队列的地址
   	 	OS_TICK
  变量	超时时间
  从调用这个函数开始算起，如果经过了超时时间，所等待的消息队列仍未释放消息，那么等待超时，调用本函数的任务进入就绪态
  如果传递的参数数值设置为0，那么该任务会一直等待下去
   	 	OS_OPT
  变量	OS_OPT_PEND_FLAG_MASK 	
   	 	 	OS_OPT_PEND_FLAG_CLR_ALL	
   	 	 	OS_OPT_PEND_FLAG_CLR_AND	
   	 	 	OS_OPT_PEND_FLAG_CLR_ANY	
   	 	 	OS_OPT_PEND_FLAG_CLR_OR	
   	 	 	OS_OPT_PEND_FLAG_SET_ALL	
   	 	 	OS_OPT_PEND_FLAG_SET_AND	
   	 	 	OS_OPT_PEND_FLAG_SET_ANY	
   	 	 	OS_OPT_PEND_FLAG_SET_OR	
   	 	 	OS_OPT_PEND_FLAG_CONSUME	
   	 	 	OS_OPT_PEND_BLOCKING	任务调用本函数的时刻，所等待的消息队列中不含
  有效消息
  该任务进入等待态，直到信号量被释放或超时
   	 	 	OS_OPT_PEND_NON_BLOCKING	任务调用本函数的时刻，所等待的消息队列中不含
  有效消息
  该任务进入就绪态，并返回相应的错误信息
  这种模式要求该消息队列一直包含有效消息
   	 	OS_MSG_SIZE
  指针	指向一个变量，这个变量用于存储要接受的消息的大小（字节数）
   	 	CPU_TS
  指针	输入一个空白的CPU_TS类型变量的地址，所等待的信号量一旦被释放，那么该信号量的TS成员就会更新，记录该信号量释放的时刻，程序将该时刻传递给该CPU_TS变量；用户获取任务继续执行时刻，就可以算出信号量从被释放到被接收的时间间隔。 
   	 	OS_ERR
  指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	void
  指针	
   	 	OS_ERR
  变量
  赋值	
   	使用	等待一个消息队列

- OSQPendAbort	输入	OS_Q
  指针	
   	 	OS_OPT
  变量	OS_OPT_PEND_ABORT_1	
   	 	 	OS_OPT_PEND_ABORT_ALL	
   	 	OS_ERR
  指针	
   	输出	OS_OBJ_QTY	
   	 	OS_ERR
  变量
  赋值	
   	使用	使能：OS_CFG_Q_PEND_ABORT_EN置1
   	 	任务H运行过程中调用OSQPend ()函数后进入等待态；
  就绪态中优先级最高的任务L进如运行态，任务L在运行过程中使用OSQPendAbort ()函数而终止了任务H对信号量的的等待；任务H的OSQPend ()函数返回OS_ERR_PEND_ABORT
  任务H进入就绪态，此时如果进行任务调度，由于任务H优先级大于任务L，那么任务H抢占CPU控制权而进入 运行态，任务L进入就绪态；

​                                                                    

- OSTaskQPend	输入	OS_TICK
  变量	超时时间
  从调用这个函数开始算起，如果经过了超时时间，所等待的消息队列仍未释放消息，那么等待超时，调用本函数的任务进入就绪态
  如果传递的参数数值设置为0，那么该任务会一直等待下去
   	 	OS_OPT
  变量	OS_OPT_PEND_FLAG_MASK 	
   	 	 	OS_OPT_PEND_FLAG_CLR_ALL	
   	 	 	OS_OPT_PEND_FLAG_CLR_AND	
   	 	 	OS_OPT_PEND_FLAG_CLR_ANY	
   	 	 	OS_OPT_PEND_FLAG_CLR_OR	
   	 	 	OS_OPT_PEND_FLAG_SET_ALL	
   	 	 	OS_OPT_PEND_FLAG_SET_AND	
   	 	 	OS_OPT_PEND_FLAG_SET_ANY	
   	 	 	OS_OPT_PEND_FLAG_SET_OR	
   	 	 	OS_OPT_PEND_FLAG_CONSUME	
   	 	 	OS_OPT_PEND_BLOCKING	任务调用本函数的时刻，所等待的消息队列中不含有效消息
  该任务进入等待态，直到信号量被释放或超时
   	 	 	OS_OPT_PEND_NON_BLOCKING	任务调用本函数的时刻，所等待的消息队列中不含有效消息
  该任务进入就绪态，并返回相应的错误信息
  这种模式要求该消息队列一直包含有效消息
   	 	OS_MSG_SIZE
  指针	指向一个变量，这个变量用于存储要接受的消息的大小（字节数）
   	 	CPU_TS指针	输入一个空白的CPU_TS类型变量的地址，所等待的信号量一旦被释放，那么该信号量的TS成员就会更新，记录该信号量释放的时刻，程序将该时刻传递给该CPU_TS变量；用户获取任务继续执行时刻，就可以算出信号量从被释放到被接收的时间间隔。 
   	 	OS_ERR
  指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	void
  指针	返回一个 任意数据类型的变量的地址
  如果没有接收到任何消息则返回NULL
  注意返回值是NULL时并不意味着一定是没有接收到任何消息，因为有可能实际的消息就是一个NULL指针，所以最保险的还是要核对返回的错误代码
   	 	OS_ERR
  变量
  赋值	
   	使用	#if OS_CFG_TASK_Q_EN > 0u

- OSTaskQPendAbort	输入	OS_TCB
  指针	
   	 	OS_OPT
  变量	OS_OPT_PEND_ABORT_1	
   	 	 	OS_OPT_PEND_ABORT_ALL	
   	 	OS_ERR
  指针	
   	输出	CPU_BOOLEAN
  变量	
   	 	OS_ERR
  变量
  赋值	
   	使用	#if OS_CFG_TASK_Q_EN > 0u



## 释放消息

将某个消息数据的地址填充到某个消息队列的某个消息中；

- OSQPost	输入	OS_Q指针	要进行填充的目标消息队列的地址
   	 	void指针	这里传递的就是上面所说的“某个消息”。即实际发送的内容。
  事先将消息内容存储在一个void类型的变量里。使用OSQPend()函数时，将这个变量的地址作为第二个参数传递给函数。
  发布消息数据采用的是指针传递而不是值传递，只是发送一个地址，数据本身不产生拷贝。
  因为是void类型的，即任意类型的变量。

这个消息要存储在某个消息队列中的时候，系统会使用到OS_MSG 结构，这个结构的成员MsgPtr要存储消息的具体内容。
 	 	OS_MSG_SIZE
变量	设定这个消息的大小（字节数）

这个消息要存储在某个消息队列中的时候，系统会使用到OS_MSG 结构，这个结构的成员MsgSize要存储消息的大小。
 	 	OS_OPT
变量	OS_OPT_POST_NONE 	
 	 	 	OS_OPT_POST_FLAG_SET	表明一旦调用该函数，所有指定的位全部置1，且调用该函数完毕后，进行任务调度
 	 	 	OS_OPT_POST_FLAG_CLR	表明一旦调用该函数，所有指定的位全部清0，且调用该函数完毕后，进行任务调度
 	 	 	OS_OPT_POST_FIFO	发送的消息存放在指定消息队列的末尾。
 	 	 	OS_OPT_POST_LIFO	发送的消息存放在指定消息队列的开头
 	 	 	OS_OPT_POST_1	表明每次调用OSTaskSemPost()函数，该信号仅释放一次。如果此时信号量的等待列表中有多个任务，那么它们中优先级最高的将进入就绪态，其余的继续等待
 	 	 	OS_OPT_POST_ALL	表明每次调用OSTaskSemPost()函数，该信号仅释放n次。n为此时信号量的等待列表中任务的个数，也即是说所有等待该信号的任务都进入就绪态。
 	 	 	OS_OPT_POST_NO_SCHED	发布信号量之后不进行任务调度，原因可能是还需要进行其他的发布操作。
 	 	 	组合	OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED 表明一旦调用该函数，所有指定的位全部置1，且调用该函数完毕后，不进行任务调度

OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED 表明一旦调用该函数，所有指定的位全部清0，且调用该函数完毕后，不进行任务调度，原因可能是还需要进行其他的发布操作。
 	 	OS_ERR
指针	每次调用OSFlagPost()函数，执行完后会返回一个错误代码。
OSFlagPost()函数不会返回这个错误类型，所以我们需要另外定义一个变量用来存储这个错误代码，在这里将这个变量的地址传给OSFlagPost()函数
OS_ERR_NONE成功释放互斥型事件标志组
OS_ERR_FLAG_NESTING调用OSFlagPost()后，互斥型事件标志组的OwnerNestingCtr减1，但并没有减到0，即该互斥型事件标志组并没有真正释放
 	输出	OS_ERR
变量
赋值	
 	使用	向某个消息队列发布一则消息



- OSTaskQPost	输入	OS_TCB
  指针	在任务A中使用OSTaskQPost()函数存储消息至任务B的内嵌消息队列时，需要将任务B的任务控制块的地址传递给OSTaskQPost()函数。
   	 	void
  指针	这里传递的就是上面所说的“某个消息”。即实际发送的内容。
  事先将消息内容存储在一个void类型的变量里。使用OSQPend()函数时，将这个变量的地址作为第二个参数传递给函数。
  发布消息数据采用的是指针传递而不是值传递，只是发送一个地址，数据本身不产生拷贝。
  因为是void类型的，即任意类型的变量。

这个消息要存储在某个消息队列中的时候，系统会使用到OS_MSG 结构，这个结构的成员MsgPtr要存储消息的具体内容。
 	 	OS_MSG_SIZE
变量	设定这个消息的大小（字节数）

这个消息要存储在某个消息队列中的时候，系统会使用到OS_MSG 结构，这个结构的成员MsgSize要存储消息的大小。
 	 	OS_OPT
变量	选择消息发送的操作类型：
OS_OPT_POST_FIFO 发送的消息存放在指定消息队列的末尾。
OS_OPT_POST_LIFO发送的消息存放在指定消息队列的开头。

OS_OPT_POST_ALL 该参数可以叠加在上两个参数后面（使用“|”符号），实现的功能是将下一个消息发送给所有等待该消息队列的任务，即广播发送

OS_OPT_POST_NO_SCHED 该参数可以叠加在上两个参数后面（使用“|”符号），实现的功能是在这个函数执行的过程中不发生任务调度。

 	 	OS_ERR
指针	每次调用OSFlagPost()函数，执行完后会返回一个错误代码。
OSFlagPost()函数不会返回这个错误类型，所以我们需要另外定义一个变量用来存储这个错误代码，在这里将这个变量的地址传给OSFlagPost()函数
OS_ERR_NONE成功释放互斥型事件标志组
OS_ERR_FLAG_NESTING调用OSFlagPost()后，互斥型事件标志组的OwnerNestingCtr减1，但并没有减到0，即该互斥型事件标志组并没有真正释放

 	输出	OS_ERR
变量
赋值	
 	使用	#if OS_CFG_TASK_Q_EN > 0u



- OS_TaskQPost

- OS_MsgPoolInit 
- OS_MsgQFreeAll
- OS_MsgQGet

- OS_MsgQInit
- OS_MsgQPut


## 消息传递
优先级：D>B>A>C

创建消息队列M	
任务A请求消息队列M	任务A想接收消息队列M中的消息，就使用OSQPend()函数向消息队列M发送请求。此时消息队列M中没有信息，所以，任务A进入等待态。
任务B请求消息队列M
	任务B想接收消息队列M中的消息，就使用OSQPend()函数向消息队列M发送请求。此时消息队列M中没有信息，所以，任务B进入等待态。
任务A和任务B都进入了消息队列的等待列表中
任务C进入运行态	
任务C把消息a放入消息队列M 	消息a就会被存储在消息队列M中。
使用OSQPost()函数，将事先已经创建好的某个消息（void类型的变量）发送给消息队列M
opt参数选择什么无所谓，因为现在只有一个消息。
任务B获取消息	因为任务B的优先级比A高，所以他优先获得响应，进入就绪态，B的优先级比C高，所以B进入运行态。
并且任务B中的OSQPend()返回所接受到的消息内容
任务B把消息b放入消息队列M	消息b就会被存储在消息队列M中。
使用OSQPost()函数，将事先已经创建好的某个消息（void类型的变量）发送给消息队列M
opt参数选择什么无所谓，因为现在只有一个消息。
任务A获取消息	消息队列M的等待列表中只有A一个任务，所以A获取消息b进入就绪态，但A的优先级低于B，所以A就保留在就绪态。
任务B把消息c放入消息队列M	消息c就会被存储在消息队列M中。
使用OSQPost()函数，将事先已经创建好的某个消息（void类型的变量）发送给消息队列M
opt参数选择什么无所谓，因为现在只有一个消息。
任务B把消息d放入消息队列M	消息d就会被存储在消息队列M中。
使用OSQPost()函数，将事先已经创建好的某个消息（void类型的变量）发送给消息队列M
opt参数选择先进先出，所以现在消息队列M中消息的排列情况是：
末尾---消息d---消息c---开头
任务B把消息e放入消息队列M	消息e就会被存储在消息队列M中。
使用OSQPost()函数，将事先已经创建好的某个消息（void类型的变量）发送给消息队列M
opt参数选择后进先出，所以现在消息队列M中消息的排列情况是：
末尾---消息d---消息c---消息e---开头
出于某些原因任务D进入了运行态	任务D本来是在等待态，任务B运行的过程中发生了中断，这个中断使任务D进入了就绪态，进入任务D的优先级是最高的，所以任务D进入运行态
任务D请求消息队列M
	任务D想接收消息队列M中的消息，就使用OSQPend()函数向消息队列M发送请求。此时消息队列M中有3个消息，所以，任务D立即进入就绪态，因为优先级最高，马上进入运行态。
现在消息队列M中消息的排列情况是：
末尾---消息d---消息c--开头


任务同步
两个任务使用两个任务消息队列进行双向同步

与使用任务信号量进行双向同步相似，两者的区别是，使用消息队列时，两个任务双方都可以向对方发布消息。
任务和ISR之间不能实现双向同步，因为ISR不能使用OSQ_Task_Pend()函数等待消息。

在双向同步中，每个消息队列最多只能容纳一条消息，在初始化时消息队列为空。



# 事件标志组

- 使能	OS_CFG_Flag_EN置1，位置：os_cfg.h
  事件标志	事件标志是一个OS_FLAGS 类型的变量，OS_FLAGS是8位或16位或32位整型，取决于OS_FLAGS在os_type.h文件中的定义；
  以8位的OS_FLAGS为例，那么一个OS_FLAGS变量可以表示8个事件，因为ucOS系统规定使用OS_FLAGS变量中的1bit 来表示一个事件，而多个bit表示它们所对应的事件的组合；
  具体一个事件标志对应什么事件由应用程序决定
  如定义事件“温度过低”的事件标志：#define  TEMP_LOW  (OS_FLAGS)0x0001
  如定义事件“电池电压过低”的事件标志：#define  BATT_LOW  (OS_FLAGS)0x0002
  那么事件“温度过低且电池电压过低”：就是(OS_FLAGS)0x0003
  事件标志组	事件标志组是一个OS_FLAG_GRP类型的结构变量，定义如下表所示，定义位置：os.h：
  除了事件标志，还包含其他一些信息，如该事件标志组的名称、任务挂起表、等
  在任意时刻，一个事件标志组只能表示一个事件标志；
  一个确定的事件标志组中的一个确定的事件标志，才能用来表示一个事件。
  如事件标志组A中的事件标志0x0001表示温度过低，而事件标志组B中的事件标志0x0001表示电池电压过低；
  OS_FLAG_GRP	成员	数据类型	说明
   	Type	OS_OBJ_TYPE变量	Type =OS_OBJ_TYPE_FLAG，表示该结构类型变量是一个事件标志组
   	NamePtr	CPU_CHAR指针	内核对象的名称，这里传递字符串数组的首地址
   	PendList	OS_PEND_LIST变量	该事件标志组的任务挂起表
   	DbgPrevPtr	OS_FLAG_GRP指针	
   	DbgNextPtr	OS_FLAG_GRP指针	
   	DbgNamePtr	CPU_CHAR指针	
   	Flags	OS_FLAGS变量	该事件标志组当前的事件标志
   	TS	CPU_TS变量	每当一个事件标志被释放，该事件标志组的的TS成员就会更新为释放时刻的时间戳
  单位：时钟节拍

- OSFlagCreate	输入	OS_FLAG_GRP指针	要初始化的事件标志组 的地址
   	 	CPU_CHAR指针	事件标志组的名称，字符串
   	 	OS_FLAGS变量	给事件标志组初始化时的事件标志
  初始化时，一般将事件标志清零，除非任务或ISR要以位0作为事件触发的标志，那么就得把相应的位初始化为1；
  总之是要与触发时的位的状态相反，不然刚创建就直接触发了。
   	 	ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	OS_ERR
  变量赋值	OS_ERR_NONE 	
   	 	 	OS_ERR_CREATE_ISR	
   	 	 	OS_ERR_ILLEGAL_CREATE_RUN_TIME	
   	 	 	OS_ERR_NAME	
   	 	 	OS_ERR_OBJ_CREATED	
   	 	 	OS_ERR_OBJ_PTR_NULL	
   	使用	函数执行时调用OS_FlagInit()函数，初始化事件标志组的各个成员的值； 
  最好在启动代码中创建事件标志组变量，因为在ucOS系统启动前，没有任务或ISR会使用事件标志组。也就是说最好在main()函数中创建事件标志组
  OSFlagDel	输入	OS_FLAG_GRP指针	要删除的事件标志组 的地址
   	 	OS_OPT变量	OS_OPT_DEL_NO_PEND 	等到没有任务在请求这个信号量时再删除它
   	 	 	OS_OPT_DEL_ALWAYS	直接删除，正等待该信号量的任务相当于获取了该信号量
   	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	OS_OBJ_QTY变量	删除这个事件标志组的时刻，等待这个事件标志组的任务的数目
   	 	OS_ERR
  变量赋值	OS_ERR_NONE	
   	 	 	OS_ERR_DEL_ISR	
   	 	 	OS_ERR_OBJ_PTR_NULL	
   	 	 	OS_ERR_OBJ_TYPE	
   	 	 	OS_ERR_OPT_INVALID	
   	 	 	OS_ERR_TASK_WAITING	
   	使用	使能： OS_CFG_FLAG_DEL_EN 置1，位置：os_cfg.h
  函数执行时调用OS_FlagClr()清零事件标志组的所有成员
  等待事件标志
  OSFlagPend	输入	OS_FLAG_GRP指针	所等待的事件标志所在的事件标志组的地址
   	 	OS_FLAGS变量	所等待的事件标志的有效位；
  1表示有效位，0表示无效位，如对于8位的OS_FLAGS，0x3A表明：
  等待时，该事件标志组的第5、4、3、2位是有效位，只看这几位是否达到预期值
   	 	OS_TICK变量	等待超时时间
   	 	OS_OPT变量	OS_OPT_PEND_FLAG_CLR_ALL	有效位全部清0时，才算获取该事件标志
   	 	 	OS_OPT_PEND_FLAG_CLR_ANY	有效位中只要有一位清0，就能获取该事件标志
   	 	 	OS_OPT_PEND_FLAG_SET_AND	有效位全部置1时，才算获取该事件标志
   	 	 	OS_OPT_PEND_FLAG_SET_ANY	有效位中只要有一位置1，就能获取该事件标志
   	 	 	OS_OPT_PEND_FLAG_CONSUME	成功获取后，有效位恢复到使用本函数之前的值
  可以和其他模式配合使用
   	 	 	OS_OPT_PEND_BLOCKING	任务进入等待态，
  直到信号量被释放或超时	可以和
  上述的模式
  配合使用
   	 	 	OS_OPT_PEND_NON_BLOCKING	任务不会等待，函数立即返回错误信息说明此信号量无效	 
   	 	CPU_TS指针	输入一个空白的CPU_TS类型变量的地址，所等待的信号量一旦被释放，那么该信号量的TS成员就会更新，记录该事件标志释放的时刻，程序将该时刻传递给该CPU_TS变量；用户获取任务继续执行时刻，就可以算出事件标志从被释放到被接收的时间间隔。 
   	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	OS_FLAGS变量	
   	 	OS_ERR
  变量赋值	
   	使用	当一个信号量的计数值从0变为1，那么等待该信号量的某个任务就能获取这个信号量而进入就绪态；
  类似的，当一个事件标志组的事件标志变为某个值时，等待 这个事件标志组 的 这个事件标志 的任务就能获取这个事件标志而进入就绪态
   	 	调用OS_FlagDbgListAdd函数，将该任务插入到该事件标志组的任务挂起表中
  插入时不按照优先级顺序，只是将该任务插入到列表的开头。这样做是因为无论事件标志组的事件标志在何时发生变化，都会检查列表中的所有任务，已确认是否有满足条件的；

- OSFlagPendAbort 	输入	OS_FLAG_GRP指针	
   	 	OS_OPT变量	OS_OPT_PEND_ABORT_1	
   	 	 	OS_OPT_PEND_ABORT_ALL	
   	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
   	输出	OS_OBJ_QTY变量	
   	 	OS_ERR
  变量赋值	
   	使用	使能：OS_CFG_FLAG_PEND_ABORT_EN 置1，定义位置：
   		任务H运行过程中调用OSFlagPend ()函数后进入等待态；
  就绪态中优先级最高的任务L进如运行态，任务L在运行过程中使用OSFlagPendAbort()函数而终止了任务H对信号量的的等待；任务H的OSFlagPend()函数返回OS_ERR_PEND_ABORT
  任务H进入就绪态，此时如果进行任务调度，由于任务H优先级大于任务L，那么任务H抢占CPU控制权而进入 运行态，任务L进入就绪态；

- OSFlagPendGetFlagsRdy	输入	OS_ERR指针	
   	输出	OS_FLAGS变量	
      	 	OS_ERR
  变量赋值	
   	使用	#if OS_CFG_FLAG_DEL_EN > 0u
  获取使任务就绪的时间标志

- OS_FlagBlock	输入	OS_PEND_DATA指针	
   	 	OS_FLAG_GRP指针	
   	 	OS_FLAGS变量	
   	 	OS_OPT变量	
   	 	OS_TICK变量	
   	输出	无	
   	使用	



## 修改事件标志

-  OSFlagPost	

  - 使用	

    OSFlagPost()在执行时会调用OS_TS_GET()函数，获得当前的时间戳，保存在互斥型事件标志组的TS成员中，以备OSFlagPend()使用。
     释放或者发出一个事件标志组
     传递的参数是一个8位的数，或一个16位的数，或一个32位的数
     表示的是这个任务要等待事件标志组中flags的值（事件标志组）
     只有当系统中有一个事件标志组被发布，且发布的事件标志组的flags与请求的事件标志组的flag完全相同时，请求得到响应。
     参数事先就创建好，再传递

- 输入	

  - OS_FLAG_GRP指针	要修改的事件标志所在的事件标志组的地址
  - OS_FLAGS变量	所修改的事件标志的有效位；  1表示有效位，0表示无效位，如对于8位的OS_FLAGS，0x3A表明：
      释放时该事件标志组的第5、4、3、2位使有效位，只操作这几位，其它位保持不变
  - OS_OPT 
    - OS_OPT_POST_FLAG_SET	有效位全部置1
    - OS_OPT_POST_FLAG_CLR	有效位全部清0
    - OS_OPT_POST_NO_SCHED	执行完该函数后，不进行任务调度，该选项可以和另外其它选项组合使用   	 	
  - OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息

- OS_FlagPost	
  - 输入	
    - OS_FLAG_GRP指针	
    - OS_FLAGS变量
    - OS_OPT变量
    - CPU_TS变量
    - OS_ERR指针	
       	

## 使用事件标志组进行监控

状态信息监控	
瞬时事件监控	

监控产品的电池电压和产品的温度两个参数。
要求一旦电池电压低于阈值，或温度高于阈值。产品就会亮红灯

定义事件标志	往往是使用#define预处理器，事先定义好
任务M将要请求的事件标志组的数值为0x01(调用OSFlagPend()函数时传递的flags参数) ；
各个目标事件释放的事件标志（调用OSFlagPost()函数时传递的flags参数）
（一个目标事件对应一个事件标志，一共两个目标事件，事件标志都设置位，将flags的第0位置1）
定义中断	编写中断服务函数：
一旦电池电压低于阈值，就会发生中断，系统进入中断服务程序ISR1，ISR1使用OSFlagPost()函数发布事件标志，传递刚刚创建的事件标志组的地址，以及事先定义好的事件标志的数值。  
一旦温度高于阈值，就会发生中断，系统进入中断服务程序ISR2，ISR2使用OSFlagPost()函数发布事件标志，传递刚刚创建的事件标志组的地址，以及事先定义好的事件标志的数值。
创建事件标志组	最好在主程序main()中创建好事件标志组，因为在系统启动前，没有任务或ISR会使用事件标志组
创建事件标志组时设置flags初始值（设置为0）
任务M请求事件标志组	任务M使用OSFlagPend()函数，传递刚刚创建的事件标志组的地址，以及事先定义好的事件标志组的数值。   进入等待态
发生目标事件
电压低于阈值/温度高于阈值	事件一旦发生，就会进入中断，执行中断服务程序ISR1或ISR2，
ISR1/ISR2 使用OSFlagPost()函数发布事件标志，
事件标志组的flags=0x01 
任务M请求获得响应	任务M进入就绪态，优先级最高，进入任务态
任务M执行处理程序	执行亮红灯的程序。


## 多任务同步
任务同步	当一个任务要和多个事件进行同步时，就会使用事件标志组
一个任务可以和另一个任务(或ISR)中的多个事件同步，也可以和多个任务(多个ISR)中的多个事件同步；
 	“或”同步	等待多个事件时，任何一个事件发生，任务都被同步(继续执行)
 	“与”同步	等待多个事件时，必须所有事件都发生，任务才被同步(继续执行)
		

有时候，可能需要使多个任务同步开始执行。虽然对于单个处理器来说，一次只能执行一个任务，但是可以把它们执行的起点同步到同一个时刻。这种情况成为多任务同步；

多个任务和1个任务(或ISR) 进行同步：
任务A在执行过程中使用Pend函数请求信号量x，
任务B在执行过程中使用Pend函数请求信号量x，
任务C在执行过程中使用Pend函数请求信号量x，
信号量x对应的事件在某个中断服务程序中，一旦该中断发生，执行ISR，在ISR中会调用OSSemPost()函数时发布信号量x，OSSemPost()选择OS_OPT_POST_ALL模式，实现广播发送；
但是广播信号量发布时，某些需要同步的任务（如任务C）可能还在执行，没有被挂起，这个问题并不难解决，将信号量和事件标志结合起来就可以了；另外事件标志组可以实现一个任务与多个事件进行同步，要和这里的情况区分开来。
但是，当进行广播操作时，一些需要同步的任务可能没有在等待信号量，

举例说明：4个任务进行同步：任务A、任务B、任务C、任务L
任务A在同步位置处使用OSFlagPost函数修改事件标志组k的事件标志：将第0位置1，然后使用OSSemPend函数请求信号量m
任务B在同步位置处使用OSFlagPost函数修改事件标志组k的事件标志：将第1位置1，然后使用OSSemPend函数请求信号量m
任务C在同步位置处使用OSFlagPost函数修改事件标志组k的事件标志：将第2位置1，然后使用OSSemPend函数请求信号量m
任务L在其同步位置处使用OSFlagPend函数请求事件标志组k的事件标志0x0007，然后使用OSSemPend函数广播发布信号量m
要求任务L的优先级最低，这是为了确保任务L在其他3个任务都进入等待状态后才广播发布信号量。
任务A、B、C都要先修改对应的事件标志，让任务L知道自己已到达同步点，
如果任务L的优先级更高，那么任务L就会过早的发布信号量m，而任务A、B、C可能还没来得及请求信号量m；


多任务同步
信号量广播与事件标志组联合使用
	“或”同步等待多个目标事件时，其中任何一个事件发生，任务就被同步
“与”同步等待多个目标事件时，其中所有的事件全部或发生，任务才被同步
1.事件标志组flags初始为0；任务请求的事件标志组是0x01；每个目标事件释放的事件标志都是只操作令flags第一位，且是将第一位置1。那么表明任意一个目标事件发生都能触发处理程序。
2. 事件标志组flags初始为0；任务请求的事件标志组是0xFF；共有8个目标事件，每个目标事件释放的事件标志置位flags其中一位。那么表明8个目标事件都发生了才能能触发处理程序。


前面讲到使用广播操作，用一个信号量来同步多任务时的缺陷，这里引入事件标志组来解决这一缺陷。假设需要同步的任务有三个：A、B、C  ， 优先级：M>A>B>C
 	任务M进入运行态并请求一个事件标志组	任务M使用OSFlagPend()函数请求一个事件标志组，这是一个“与”类型的套路，需要3个事件标志，任务M进入等待态。
 	任务A进入运行态	任务A使用OSFlagPost()函数发布一个事件标志
 	任务A请求信号量m	任务A使用OSSemPend()函数请求信号量m，进入等待态
 	任务B进入运行态	任务B使用OSFlagPost()函数发布一个事件标志
 	任务B请求信号量m	任务B使用OSSemPend()函数请求信号量m，进入等待态
 	任务C进入运行态	任务C使用OSFlagPost()函数发布一个事件标志
 	任务C请求信号量m	任务C使用OSSemPend()函数请求信号量m，进入等待态
 	任务M的事件标志组请求得到响应	3个事件标志释放后，满足任务M在之前所请求的flags的值，于是任务M进入就绪态，由于优先级
最高，进入运行态
 	任务M进入运行态	任务M使用OSSemPost()函数释放信号量m，使用广播操作， 
 	任务A,B,C都进入就绪态	这时任务A,B,C实现同步

 

# 任务管理
## 任务

OS_TCB
一个任务对应一个任务控制块；任务控制块就是一个OS_TCB结构类型的变量；
每个成员代表该任务一种属性，下面进行一些简单的说明

任务名称	NamePtr	OS_CHAR指针	任务名称，字符串
任务
当前状态	TaskState	OS_STATE变量	OS_TASK_STATE_RDY	
 	 	 	OS_TASK_STATE_DLY	
 	 	 	OS_TASK_STATE_PEND	
 	 	 	OS_TASK_STATE_PEND_TIMEOUT	
 	 	 	OS_TASK_STATE_SUSPENDED	
 	 	 	OS_TASK_STATE_DLY_SUSPENDED	
 	 	 	OS_TASK_STATE_PEND_SUSPENDED	
 	 	 	OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED	
 	 	 	OS_TASK_STATE_DEL	
任务优先级	Prio	OS_PRIO变量	任务优先级
任务堆栈	StkPtr	CPU_STK指针	任务堆栈指针的当前值，即任务堆栈数组中某个元素的地址；
 	StkLimitPtr	CPU_STK指针	任务堆栈数组某个元素的地址；
 	StkBasePtr	CPU_STK指针	任务堆栈的基地址
 	StkSize	CPU_STK_SIZE变量	任务堆栈的总容量
 	StkUsed	CPU_STK_SIZE变量	任务堆栈已使用的容量
 	StkFree	CPU_STK_SIZE变量	任务堆栈空闲的容量
 	Opt	OS_OPT
变量	OS_OPT_TASK_NONE	没有任何选项
 	 	 	OS_OPT_TASK_STK_CHK	任务创建时检测该任务的堆栈
 	 	 	OS_OPT_TASK_STK_CLR	任务创建时清0该任务的堆栈
 	 	 	OS_OPT_TASK_SAVE_FP	任务创建时储存浮点运算寄存器。
 	 	 	OS_OPT_TASK_NO_TLS	
 	 	 	组合效果	可以使用“|”，实现多个效果
任务函数	TaskEntryAddr	OS_TASK_PTR变量	任务的入口地址，
如果该任务的任务函数是：void MyTask(void *p_arg)
那么TaskEntryAddr=&MyTask
 	TaskEntryArg	void指针	如果该任务的任务函数是：void MyTask(void *p_arg)
那么程序执行该任务函数代码时，将TaskEntryArg作为参数传递


CPU	CPUUsage	OS_CPU_USAGE变量	表示该任务的CPU利用率
 	CtxSwCtr	OS_CTX_SW_CTR变量	表示任务执行的频繁程度，
 	CyclesDelta	CPU_TS变量	等于当前时间戳的数值，用于取得该任务在一次运行期间占用CPU的时间
 	CyclesStart	CPU_TS变量	表示一个任务已经占用CPU的时间，每当系统进行任务切换，
 	CyclesTotal	OS_CYCLES变量	CyclesTotal是CyclesDelta的累计值
 	CyclesTotalPrev	OS_CYCLES变量	

成员	类型	说明
ExtPtr	void
指针	任意数据类型
用于扩展TCB

成员	类型	说明
RegTbl[OS_CFG_TASK_REG_TBL_SIZE]	OS_REG变量	任务寄存器
IntDisTimeMax	CPU_TS变量	该任务的最大中断关闭时间
SchedLockTimeMax	CPU_TS变量	该任务给调度器上锁的最长时间
TimeQuanta	OS_TICK变量	该任务分配到的时间片，单位：时钟节拍
TimeQuantaCtr	OS_TICK变量	该任务时间片的剩余值，单位：时钟节拍


双向
链表		成员	类型	说明
 	OS_TCB
双向链表	DbgPrevPtr	OS_TCB指针	在OS_TCB双向链表中，本任务控制块前一个任务控制块的地址
 	 	DbgNextPtr	OS_TCB指针	在OS_TCB双向链表中，本任务控制块下一个任务控制块的地址
 	任务
就绪表	PrevPtr	OS_TCB指针	在优先级双向链表中，本任务控制块前一个任务控制块的地址
 	 	NextPtr	OS_TCB指针	在优先级双向链表中，本任务控制块的下一个任务控制块的地址
 	任务
挂起表	PendDataTblPtr	OS_PEND_DATA
指针	PendDataTblPtr->PrevPtr	在任务挂起表中，本挂起项前一个挂起项的地址
 	 	 	 	PendDataTblPtr->NextPtr	在任务挂起表中，本挂起项下一个挂起项的地址
 	时钟节拍
列表	TickPrevPtr	OS_TCB指针	在时钟节拍列表中，本任务控制块的前一个任务控制块的地址
 	 	TickNextPtr	OS_TCB指针	在时钟节拍列表中，本任务控制块的下一个任务控制块的地址
 	 	TickSpokePtr	OS_TICK_SPOKE
指针	在时钟节拍列表中，本任务所处的辐条的地址；
ucOS系统使用OS_TICK_SPOKE变量表示一个辐条
 	 	TickCtrPrev	OS_TICK变量	本任务延时或超时判断的启动时刻，时钟节拍计数器OSTickCtr的值 
 	 	TickCtrMatch	OS_TICK变量	本任务延时或超时判断的终止时刻，时钟节拍计数器OSTickCtr的值
 	 	TickRemain	OS_TICK变量	本任务延时或等待超时的剩余时间，单位：时钟节拍
TickRemain= TickCtrMatch– OSTickCtr
 	如果表中只有一个表项，那么NextPtr和PrevPtr均指向这个唯一的表项
挂起
状态	PendDataTblEntries	OS_OBJ_QTY变量	任务正在等待的内核对象的总数目
 	PendOn	OS_STATE
变量	任务正在
等待的
内核对象
的类型	OS_TASK_PEND_ON_NOTHING	
 	 	 	 	OS_TASK_PEND_ON_FLAG	
 	 	 	 	OS_TASK_PEND_ON_TASK_Q	
 	 	 	 	OS_TASK_PEND_ON_MULTI	
 	 	 	 	OS_TASK_PEND_ON_MUTEX	
 	 	 	 	OS_TASK_PEND_ON_Q	
 	 	 	 	OS_TASK_PEND_ON_SEM	
 	 	 	 	OS_TASK_PEND_ON_TASK_SEM	
 	PendStatus	OS_STATUS
变量	等待
结果	OS_STATUS_PEND_OK	
 	 	 	 	OS_STATUS_PEND_ABORT	
 	 	 	 	OS_STATUS_PEND_DEL	
 	 	 	 	OS_STATUS_PEND_TIMEOUT	
 	TS	CPU_TS变量	当该任务等待的对象释放时，TS记录释放的时间戳
 	SuspendCtr	OS_NESTING_CTR
变量	表示任务挂起嵌套的层数
该成员会被OSTaskSuspend()和OS_TaskResume()这两个函数使用
 	DbgNamePtr	CPU_CHAR指针	当任务处于挂起状态时，该成员指向任务所等待的对象的名字；
信号量	SemCtr	OS_SEM_CTR变量	该任务的内嵌信号量的计数值
 	SemPendTime	CPU_TS变量	
 	SemPendTimeMax	CPU_TS变量	
消息
队列	MsgPtr	void指针	
 	MsgSize	OS_MSG_SIZE变量	
 	MsgQ	OS_MSG_Q变量	
 	MsgPendTime	CPU_TS变量	
 	MsgPendTimeMax	CPU_TS变量	
事件
标志组	FlagsPend	OS_FLAGS变量	
 	FlagsRdy	OS_FLAGS变量	
 	FlagsOpt	OS_OPT
变量	主
选
项	OS_OPT_PEND_FLAG_CLR_ALL	
 	 	 	 	OS_OPT_PEND_FLAG_CLR_ANY	
 	 	 	 	OS_OPT_PEND_FLAG_CLR_AND	
 	 	 	 	OS_OPT_PEND_FLAG_CLR_OR	
 	 	 	 	OS_OPT_PEND_FLAG_SET_ALL	
 	 	 	 	OS_OPT_PEND_FLAG_SET_ANY	
 	 	 	 	OS_OPT_PEND_FLAG_SET_AND	
 	 	 	 	OS_OPT_PEND_FLAG_SET_OR	
 	 	 	辅助选项	OS_OPT_PEND_FLAG_CONCUME	
 	 	 	 	OS_OPT_PEND_FLAG_BLOCKING	
 	 	 	 	OS_OPT_PEND_FLAG_NON_BLOCKING	




### 创建任务
OSTaskCreate	输入	OS_TCB指针	输入要创建的任务的任务控制块的地址
 	 	CPU_CHAR指针	任务的名称，字符串
 	 	OS_TASK_PTR变量	任务函数的地址，即任务函数的函数名
 	 	void指针	任务被创建时，传递给任务函数的参数的数值；
 	 	OS_PRIO变量	任务优先级，范围：[1 ~~ OS_CFG_PRIO_MAX–2]  
 	 	CPU_STK指针	任务堆栈数组的首地址
 	 	CPU_STK_SIZE变量	任务堆栈的深度限位
 	 	CPU_STK_SIZE变量	任务堆栈数组容量
 	 	OS_MSG_QTY变量	任务消息队列能存储的消息的数目，如果设置为0，那就禁止该任务接收消息。
 	 	OS_TICK变量	时间片长度(使能时间片轮转调度时才有效)，单位：时间节拍
 	 	void指针	指向用户补充的存储区
 	 	OS_OPT
变量	OS_OPT_TASK_NONE	没有任何选项
 	 	 	OS_OPT_TASK_STK_CHK	任务创建时检测该任务的堆栈
 	 	 	OS_OPT_TASK_STK_CLR	任务创建时清0该任务的堆栈
 	 	 	OS_OPT_TASK_SAVE_FP	任务创建时储存浮点运算寄存器。
 	 	 	组合效果	可以使用“|”，实现多个效果
 	 	OS_ERR指针	返回错误代码
 	输出	OS_ERR
变量赋值	
 	使用	调用OS_RdyListInsertTail函数
将该任务插入到 其优先级对应的的任务就绪表 的尾部，之所以插入到尾部，是考虑到位于双向链表头部的任务可能是新任务的创建者，并且在同一优先级下，因此没有理由让新建的任务成为下一个被执行的任务。
实际上，如果一个任务进入就绪态时和当前运行的任务的优先级相同，那么进入就绪态的任务将会被插入到双向链表的尾部。
然而，如果进入就绪态的任务和当前运行的任务的优先级不一样，那么进入就绪态的任务将会被插入到双向链表的首部。
 	 	调用OSTaskCreateHook函数

OSTaskDel	输入	OS_TCB指针	要删除的任务的任务控制块的地址
 	 	OS_ERR指针	
 	输出	OS_ERR
变量赋值	
 	使用	使能：OS_CFG_TASK_DEL_EN > 0u

 	 	调用OSTaskDelHook函数



### 任务堆栈
定义	任务堆栈是一个CPU_STK类型的数组，存储在RAM的一段连续的存储空间中；
CPU_STK是n位无符号整型，n的取值根据所使用的CPU，
一个任务对应一个任务堆栈，任务堆栈至始至终伴随着任务，与之共存亡；
举例说明：
为一个任务创建一个任务堆栈

任务堆栈的大小和任务代码中临时变量的数目有关，即任务函数中所使用的局部变量；
如果任务的临时变量很多，堆栈就应设计的大一些
一般不会去自己计算某个任务需所需要的任务堆栈空间大小；
可以给某个任务分配一个很大的存储空间并启动系统，然后通过监视该任务在运行时所用的栈空间，将这个值乘以一个安全系数（1.5~~2之间）就可以知道这个任务需要分配的栈空间大小。
一些编译器能够直接提供这种信息。

堆栈容量	堆栈数组的元素个数；
单位：CPU_STK的定义类型，如上述为32位无符号整型，那么传递的参数是256就表示任务堆栈大小为256*32bit = 1024byte = 1kb
赋值任务控制块的成员StkSize
堆栈基地址	堆栈数组的首地址
堆栈指针	堆栈指针SP是堆栈中某一个存储单元的地址；
一个任务对应一个任务堆栈对应一个任务堆栈指针；堆栈指针的取值总是与最新入栈的数据的存储地址有关；
往往会专门使用一个CPU寄存器，用来存储堆栈指针SP的值；
在ucOS–III系统中，使用任务控制块的第一个参数StkPtr存储 该任务 的 任务堆栈 的 堆栈指针 的 值
堆栈
大小	

 	配置os_cfg.h
OS_CFG_STK_SIZE_MIN
增长限位值
/
深度标记	可以代表栈溢出之前栈内因该剩余的空间大小(以CPU_STK为单位)
传递的变量类型是CPU_STK，CPU_STK的定义在cpu.h中：
typedef  CPU_INT32U               CPU_STK;
typedef  unsigned  int         CPU_INT32U;          /* 32–bit unsigned integer*/
那么传递的是一个32位无符号整型数据。

注意传递的数字的单位！比如传递一个数256，那表示任务堆栈的大小是256位还是256bit 还是256byte 还是256kb……？？
规定单位就是CPU_STK的定义类型，如上述为32位无符号整型，那么传递的参数是256就表示任务堆栈大小为
256*32bit = 1024byte = 1kb
功能	存储
局部变量	任务运行时：存储任务函数中所使用的局部变量：

 	存储
CPU寄存器	任务挂起时：存储挂起前各个CPU寄存器的值：
在挂起前，需要把任务的运行现场放到堆栈里保护起来，等到再次返回到该任务时，再把这个现场还原，任务就能从上次断点处紧接着运行。这个现场就是CPU的现场，也就是各个CPU寄存器的值
CPU寄存器
保存当前任务的现场到当前任务的堆栈中（主要是CPU相关的寄存器），恢复新任务的现场并执行新任务。
任务切换会给系统带来一定的负担。CPU的寄存器越多，任务切换的负担就越重。任务切换的时间取决于有多少寄存器需要保存和恢复。
实现任务切换的代码在ucos–III 中与处理器相关的移植部分， 
以一个虚构的CPU为例：这个CPU有16个整形寄存器R0~R15，和一个状态寄存器SR。
其中
R14是一个堆栈指针TSP/ISP
R15是一个程序计数器PC。
每个寄存器都是32位的



举例说明：
一个堆栈的存储区域为[0x500,0x1500]在某一时刻，其最新入栈的数据存储在地址0x1000
满递增	此刻	堆栈指针指向的存储单元包含有效数据，即指向 最新入栈的数据所在的存储单元
所以此刻SP=0x1000
栈顶=，栈底=
 	入栈	先递增堆栈指针数值，SP=0x1001；
再存储数据，新数据存储在地址为0x1001的存储单元里；
栈顶=，栈底=
 	出栈	先释放地址为0x1000的存储单元里的数据；
再递减堆栈指针数值，SP=0x999
栈顶=，栈底=
空递增	此刻	堆栈指针指向的存储单元是空的，即其值为 存储下一个入栈的数据的存储单元的地址
所以此刻SP=0x1001
 	入栈	先存储数据，新数据存储在地址为0x1001的存储单元里；
再递增堆栈指针数值，SP=0x1002；
 	出栈	先递减堆栈指针数值，SP=0x1000，
然后释放地址为0x1000的存储单元里的数据
满递减	此刻	堆栈指针指向的存储单元包含有效数据，即指向 最新入栈的数据所在的存储单元
所以此刻SP=0x1000
 	入栈	先递减堆栈指针数值，SP=0x999；再存储数据，
新数据存储在地址为0x999的存储单元里；
 	出栈	先释放地址为0x1000的存储单元里的数据；
再递减堆栈指针数值，SP=0x999
空递减	此刻	堆栈指针指向的存储单元是空的，即其值为 存储下一个入栈的数据的存储单元的地址
所以此刻SP=0x999
 	入栈	先存储数据，新数据存储在地址为0x999的存储单元里；
再递减堆栈指针数值，SP=0x998；
 	出栈	先递增堆栈指针数值，SP=0x1000，
然后释放地址为0x1000的存储单元里的数据

以满递增为例，说明任务挂起时堆栈的操作：
任务挂起时，程序计数器和状态寄存器首先入栈，这两者是在任务挂起时由CPU自动保存的，而其他CPU寄存器的值则中断服务程序中由软件代码压入堆栈的。
当任务挂起时，任务堆栈中保存任务挂起前CPU寄存器的这一连续的区域确定在整个堆栈的最上面；当任务重新开始运行时，SP弹出寄存器的值，这段区域变成空白的区域。而且，任务每次挂起前用来保存当前CPU寄存器这一连续区域在整个任务堆栈空间中是浮动的。


任务创建函数 OS_Task_Create() 会调用任务堆栈初始化函数OSTaskStkInit() ，
所以任务堆栈的创建和初始化在任务创建的时候完成；

创建	在RAM中为某个任务开辟一块专属的存储区域：

初始化	OSTaskStkInit() 把任务运行开始时CPU寄存器应处的状态（正确值）准备好，
任务第一次被内核调度器调度运行时，将这些准备好的数据（寄存器的值）推到CPU的寄存器中，如果数据设计的合理，CPU便会按照我们预先设计好的思路运行；


	CPU寄存器初始值的取值：
这段代码还未被履行过，所以代码中的变量与CPU的其它寄存器一点关系也没有，因此R0–R12，R14可随便给值，或者不赋值也可，让这些寄存器保持原来的值，显然后者更为简单。
最后再给CPSR赋值，用户可以根据实际需要使系统运行于系统模式或管理模式。
经过入栈和出栈，此时SP指向任务堆栈的最底端（就是已经定义好的任务堆栈数组的最后一个元素）。
之后任务代码开始正式运行，因为CPU的寄存器是有限的，所以在运行时不可避免地要把一些临时变量暂时保存到堆栈中。具体应保存到哪个地址呢，不用担心，SP知道（任务第一次运行时，这个地址就是任务堆栈数组的最后一个元素的地址）。



OSTaskStkInit	输入	OS_TASK_PTR
变量	
 	 	void
指针	
 	 	CPU_STK
指针	
 	 	CPU_STK
指针	
 	 	CPU_STK_SIZE
变量	任务堆栈的大小

 	 	OS_OPT
变量	
 	输出	CPU_STK
指针	
 	使用	


任务堆栈
溢出检测		
 	MMU
或
MPU	如果所使用的处理器有存储器管理单元MMU，或存储器保护单元MPU，那么任务堆栈溢出检测就会很单
 	硬件
监测	有一些处理器没有MMU、MPU，但也可以检测任务堆栈溢出，它有简单地堆栈指针溢出检测寄存器。
当CPU的堆栈指针低于或者高于(究竟是低于还是高于 和 堆栈的入栈方向有关) 该寄存器的设置值时，一个异常就会发生，异常的处理程序会确保有问题的代码不进一步伤害系统。
注意堆栈溢出检测限位一般应设在任务堆栈的有效区域内，并且CPU没有单独的异常处理堆栈时应该在任务堆栈中流出足够的空间来处理可能出现的异常。
大多数情况下，堆栈限定位可以非常靠近 &MyTaskStk[0]
创建任务的时候，传递给函数OSTaskCreate()的参数stk_limit 确定了 .StkLimitPtr 的位置。
当系统进行任务切换的时候，CPU堆栈溢出检测硬件所使用的.StkLimitPtr数值也会随着改变。
改变堆栈限位值是有技巧的，首先应该改变堆栈溢出检测寄存器的数值，使之指向NULL；然后改变CPU堆栈指针寄存器的数值；
最后再改变堆栈溢出检测寄存器的数值，使之等于TCB中的.StkLimitPtr的值。
如果不这么做，一旦改变堆栈指针寄存器或改变堆栈溢出检测寄存器的值，就会产生异常。通过首先发辫堆栈溢出检测寄存器的数值，使其指向一个永远不会造成堆栈指针无效的位置（就是NULL），就可以避免这种问题。
注意在这里，假设了堆栈入展方向是从存储器高地址到低地址。
 	软件
监测
	有些处理器没有硬件堆栈指针溢出检测功能，那就只能自己编写软件代码来检测，即软件检测。
只要系统进行任务切换，就会调用一个接入函数，该函数使开发人员能够扩展切换函数的功能。
软件检测时，通过在任务切换接入函数中添加相关代码，并且在软件中做堆栈溢出检测，也可以模拟硬件实现堆栈溢出检测功能。
注意：在切换到一个任务之前，介入函数中的代码必须确保载入CPU的堆栈指针不能超过.StkLimitPtr中存放的限制值。因为一旦超过，软件就可能无法正常工作，也就无法进行溢出检测了。
所以在设定.StkLimitPtr的值的时候，要使其远离 &MyTaskStk[0]
软件检测肯定不如硬件可靠的。
 	计算空间对栈空间的数量
	首先，在任务创建的时候，把任务的栈空间全部清零。
让一个低优先级的任务从任务堆栈的底部（&MyTaskStk[0] ） 开始 到顶部遍历每个已创建任务的栈空间，计算为0的数值项的个数。
当该任务发现第一个不为0的数值时，就会停止遍历操作，并计算栈的使用量（可用已使用的字节数，或使用的百分比表示）。
通过检测结果重新编译代码，调整堆栈的大小。
为了使这种方法有效，用户需要让应用程序运行足够常的时间，从而使堆栈使用量能达到它的最大值。
在μC/OS–III中有一个函数 OSTaskStkChk()可以帮助完成这种计算。


OSTaskStkChk	输入	OS_TCB
指针	
 	 	CPU_STK_SIZE
指针	
 	 	CPU_STK_SIZE指针	
 	 	OS_ERR
指针	
 	输出	OS_ERR
变量
赋值	
 	使用	#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u


### 任务状态
就绪态	所有任务要进入运行态，必定是从就绪态进入运行态；
uc/OS是一个可剥夺型内核：当一个比当前正在运行的任务的优先级更高的任务就绪，那么系统会立即进行任务切换：将当前正在执行的任务的CPU使用权剥夺，交给最高优先级的任务使用；被剥夺CPU控制权的那个任务会回到任务就绪表中；
系统总是运行优先级最高的就绪任务
运行态	当前的任务等待某一事件发生，而事件还没有发生，任务从运行态进入等待态，丧失CPU的控制权。
那么此时会立即启动调度器，确定接下来执行哪个任务。

要确保每个任务都需要等待某个事件的出现，否则该任务就成为一个真正的无限循环，那么其他优先级级较低的任务无法得到执行了。
任务所等待的事件可能只是一段延时的结束，
等待态	又称为挂起态，任务在等待一个事件时，是进入任务的等待态，不会占用CPU
处于等待态的任务会被放入一个与该任务所等待的事件相对应的等待表中
休眠态	使用OSTaskDel()函数进入 删除态=休眠态
当不再需要系统管理某个任务时，用户就可以调用函数OSTaskDel()删除它，实际上，调用这个函数并不会删除一个任务的代码，仅仅是使该任务无法再获得CPU的使用权，即再次进入休眠状态
如果是一个运行至完成型任务，那么在最后一定要使用OSTaskDel函数将自己删除。
这种任务在完成其工作后就会结束运行。
因为这种任务一会儿创建，一会儿又要删除，很麻烦，在嵌入式系统中尽量不要使用这种任务类型。

无线循环类型	大多数任务是无限循环
无线循环类型的任务用于执行重复性的工作，如：读取输入值、刷新显示器、执行某些控制操作等；
每一种重复性的工作都对应一个服务函数，系统让这些服务函数进入挂起状态，等待某个内核对象，一旦相应内核对象出现，服务函数就会执行，
任务函数执行完毕后进入挂起状态，等待下一次执行；

运行至完成类型	在最后要使用OSTaskDel函数将自己删除。
这种任务在完成其工作后就会结束运行。
因为这种任务一会儿创建，一会儿又要删除，很麻烦，在嵌入式系统中尽量不要使用这种任务类型。
任务参数	定义任务函数时必须定义一个参数  void *p_arg
如果任务不需要使用参数，那么在任务函数代码中使用    (void)p_arg;    语句，这个语句不产生任何效应，只是为了避免出现警告（p_arg定义了但未使用）。

注：任务不允许返回
调用函数
	用户在编写任务代码的时候，既可以调用C语言函数。也可以调用汇编语言函数。
只要函数是可重入的，就可以在不同的任务重调用这个函数(其实任务就是一个函数，意思就是在定义任务函数的时候调用其他函数)。
可重入的函数是指，它使用的变量就在函数内部定义，即使用局部变量。 不使用静态变量(static) 或全局变量；除非使用的静态变量或全局变量已经被加上了多重访问保护机制。

以上这么做的目的其实就是保证一个任务的独立性！

一个不可重入的函数的例子––strtok()函数
这个函数在绝大多数C编译器中都会提供，功能是把一个ASCII字符串分割成一个一个的片段。
第一次调用这个函数的时候，需要制定待分割的的字符串和分隔符，函数执行完会返回分割出的各个片段的指针； 这个函数会记住上次分割的位置，再次调用时，还能根据上次指定的分隔符分解。

使用全局变量
	任务也可以调用全局变量，因为μC/OS–III是一个可剥夺型内核，既然是全局变量，就可以被多个任务共享，因此在访问全局变量的时候吗，要小心。
幸运的是，μC/OS–III提供了保护机制，即多重访问保护机制，(信号量、互斥型信号等)，可以用来帮助管理这类共享变量。

访问外设
	


### 任务寄存器
OSTaskRegGet	输入	OS_TCB
指针	
 	 	OS_REG_ID
变量	
 	 	OS_ERR
指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_REG
变量	
 	 	OS_ERR
变量
赋值	
 	使用	OS_CFG_TASK_REG_TBL_SIZE > 0u


OSTaskRegGetID	输入	OS_ERR
指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_REG_ID
变量	
 	 	OS_ERR
变量
赋值	
 	使用	OS_CFG_TASK_REG_TBL_SIZE > 0u


OSTaskRegSet	输入	OS_TCB
指针	
 	 	OS_REG_ID
变量	
 	 	OS_REG
变量	
 	 	OS_ERR
指针	传递一个空白的OS_ERR变量，用于存储错误信息
 			
 	输出	OS_ERR
变量赋值	
 	使用	OS_CFG_TASK_REG_TBL_SIZE > 0u



初始化

OSInit	输入	OS_ERR指针	
 	输出	OS_ERR
变量赋值	
 	使用	调用OSInitHook()函数
OSCfg_Init	输入	无	
 	输出		
 	使用	
OS_TaskBlock	输入	OS_TCB
指针	
 	 	OS_TICK
变量	
 	输出	无
 	使用	
OS_TaskInit	输入	OS_ERR
指针	
 	输出	OS_ERR
变量赋值	
 	使用	
OS_TaskInitTCB	输入	OS_TCB指针	
 	输出	无
 	使用	
OS_TaskReturn	输入	无
 	输出	无
 	使用	

OS_Dbg_Init	使能：OS_CFG_DBG_EN 置1，位置：
OS_TaskDbgListAdd	输入	OS_TCB
指针	
 	使用	使能： OS_CFG_DBG_EN置1，位置：

OS_TaskDbgListRemove	输入	OS_TCB
指针	
 	输出	无
 	使用	使能：OS_CFG_DBG_EN置1，位置：






### 空闲任务
os.h	错误
信号	OS_ERR_TASK_DEL_IDLE	
 	 	OS_ERR_TASK_SUSPEND_IDLE	
 			
 		OS_AppIdleTaskHookPtr	
 		OSIdleTaskCtr	
 		OSIdleTaskTCB	
 			
 		OSCfg_IdleTaskStkBasePtr	
 		OSCfg_IdleTaskStkLimit	
 		OSCfg_IdleTaskStkSize	
 		OSCfg_IdleTaskStkSizeRAM	
 		OSCfg_IdleTaskStk[]	
os_cpu.h
		OS_CFG_IDLE_TASK_STK_SIZE	
os_cfg_app.h
		OS_CFG_IDLE_TASK_STK_SIZE	
			


void          OS_IdleTask               (void                  *p_arg);
void          OS_IdleTaskInit           (OS_ERR                *p_err);
void          OSIdleTaskHook            (void);
void  App_OS_IdleTaskHook (void)


OS_IdleTask	输入	void
指针	
 	输出	无
 	使用	
OS_IdleTaskInit	输入	OS_ERR指针	
 	输出	OS_ERR
变量
赋值	
 	使用	

OSIdleTaskHook	输入	无	
 	输出		
 	使用	


### 统计任务

extern  CPU_STK     * const OSCfg_StatTaskStkBasePtr;
extern  CPU_STK_SIZE  const OSCfg_StatTaskStkLimit;
extern  CPU_STK_SIZE  const OSCfg_StatTaskStkSize;
extern  CPU_INT32U    const OSCfg_StatTaskStkSizeRAM;
#if (OS_CFG_STAT_TASK_EN > 0u)
extern  CPU_STK        OSCfg_StatTaskStk[];

OS_StatTask	输入	void
指针	
 	输出	无
 	使用	#if OS_CFG_STAT_TASK_EN > 0u

OS_StatTaskInit	输入	OS_ERR指针	
 	输出	OS_ERR
变量
赋值	
 	使用	

OSStatTaskHook	输入	无	
 	输出		
 	使用	


## 任务就绪
任务就绪态
休眠态
	休眠态是个特殊的状态，严格来讲不能把它作为任务的一种状态。
休眠态是指任务已经存在于存储器中，但还不受μC/OS–III系统的管理。
在系统内部，系统并不需要记录任务的休眠态。
每个任务都希望就绪，因为就绪是任务实现功能的唯一途径。

就绪态
	可以有任意个任务处于就绪态，
就绪的任务被放入任务就绪表中


任务优先级
优先级	OS_PRIO位无符号整型，用于定义优先级变量
范围：[0 , OS_CFG_PRIO_MAX–1] 
数值越小，优先级越高； 6—2 
优先级
总个数	OS_CFG_PRIO_MAX，定义位置：os_cfg.h
0表示最高优先级，OS_CFG_PRIO_MAX–1 表示最低优先级
如：OS_CFG_PRIO_MAX=64，那么最低优先级就是63
并不是说用户只能使用64个任务，系统允许多个任务运行在同一个优先级(优先级0和优先级63 除外)
优先级
分配	保留
优先级	最高优先级0
固定且唯一分配给了中断处理任务，其他任务不可以使用这个优先级。
 	 	最低优先级OS_CFG_PRIO_MAX–1
固定且唯一分配给了空闲任务，其他任务不可以使用这个优先级。
 	系统
任务	除了中断处理任务和空闲任务外还有3个系统任务，一般情况下，它们的优先级由高到低排列：
时钟节拍任务>定时器任务>统计任务
 		对于实时性要求高的任务应该分配较高的优先级。
　　
比如我们刚刚举例的串口运行任务，我们都知道当串口接收到一个数据以后，它需要在一定的时间内把这个数据处理完，并且返回到上位机，上位机是不可能一直等待这个数据的，所以说我们对这个串口的执行它就有一个时间的要求，也就是实时性要求较高，那对于这个任务，我们就要分配一个较高的优先级。

 		对于运行速度较快的任务应该分配较高的优先级
 		任务在逻辑之前的要分配较高的优先级。
就是我们刚刚说的，我们首先是扫描开路，扫描按键，接下来我们才能进行逻辑的处理。所以说我们的扫描开路，扫描按键要比逻辑处理的优先级要高，否则的话，我们还没有进行开关量扫描，已经开始处理逻辑了，这个时候，就发生了一个错误。


静态优先级	这个优先级被分配以后，它在任务的运行过程中，或者说在这个系统的运行过程中，它的优先级就不能变了，比如说，我们把这个优先级分配为2，那这个任务在运行过程中就一直为2，没办法变成其他的优先级。

数值越低，优先级越高
允许多个任务有相同的优先级，优先级相同的情况详见时间片轮转调度
	
动态优先级	使能：OS_CFG_TASK_CHANGE_PRIO_EN=1 ，定义位置：os_cfg.h
 	可以使用OSTaskChangePrio函数改变任务的优先级；
在任务的运行过程中，它本身是2这个优先级，但是在运行过程中，它还可以变成3，变成4，变成n这个数，那这个过程就被称为动态优先级，也就是说这个优先级在系统的运行过程中，会出现一个可以变化的过程，ucos是一个支持动态优先级的一个系统，也就是说，我们的ucos可以在系统运行的过程中，来更改一个任务的优先级，这点我们需要注意。
　　
对任务优先级分配首先需要做的有哪些事情呢？
　　	
假设系统中有1,2,3,4,5，这5个任务，第一个任务对我们开关的输入信号进行扫描，第二个任务处理我们的按键，第三个任务处理我们的串口通信，第四个任务进行我们的系统逻辑处理，比如我们的开关量输出，第五个任务运行我们的LCD屏显示，假设我们对这5个任务分配优先级怎么分配呢？
　　
第一个我们必须把前3个任务的分配优先级要比后两个要高，为什么呢？
　　
因为从逻辑上来说，我们是首先进行开关量扫描，进行按键处理，进行串口通信，接下来，才进行逻辑处理，因为在逻辑处理当中，我们有可能用到开关量扫描，按键处理，和串口等等这些信息，所以说我们分配优先级的时候前3个任务的分配优先级要比后两个要高，对于这个输出和LCD屏显示，我们来看看这两个怎么处理，首先一般来说LCD屏显示是一个比较缓慢的过程，因为LCD屏显示是一个慢速的设备，那第四个逻辑处理和开关量输出运行速度比较快，那我们就把第四个的优先级要比第五个的高一点，那也就是说，对于一个任务，它运行的时间越短，分配的优先级越高，这是为什么呢？
　　
非常简单，因为我们刚刚说了ucos是一个可剥夺性内核，也就是说，如果有高任务在运行，那么这个低任务它是没办法运行的，那如果这个任务占用的时间比较少，我们就把它放到一个较高的任务上，那它就能很快的执行完毕，这样我们的CPU就可以较快的执行一些其他的任务了，这个是我们在使用优先级分配的一个问题，优先级的分配不是那么容易的，我们对一个比较好的操作系统要好好来考虑这个优先级的分配，如果优先级的分配的不好，就可能出现——优先级反转


OS_MutexGrpPrioFindHighest
	输入	OS_TCB

指针	
 	输出	OS_PRIO
变量	
 	使用	
OSTaskChangePrio	输入	OS_TCB
指针	
 	 	OS_PRIO
变量	
 	 	OS_ERR
指针	
 	输出	OS_ERR
变量赋值	
 	使用	#if OS_CFG_TASK_CHANGE_PRIO_EN > 0u

OS_TaskChangePrio	输入	OS_TCB
指针	
 	 	OS_PRIO
变量	
 	输出	无
 	使用	#if OS_CFG_TASK_CHANGE_PRIO_EN > 0u


OS_PrioInit	输入	无	
 	输出	无
 	使用	
OS_PendListInsertPrio	输入	OS_PEND_LIST
指针	
 		OS_PEND_DATA
指针	
 	输出	无	
 	使用	
OS_PendListChangePrio	输入	OS_TCB
指针	
 	输出	无	
 	使用	



### 就绪优先级位映射表

定义	就绪优先级位映射表就是一个CPU_DATA类型的数组OSPrioTbl[OS_PRIO_TBL_SIZE]，定义位置：os_prio.c
在系统中只有一个就绪优先级位映射表
CPU_DATA是n位无符号整型，n可取8、16、32，用户根据所使用的CPU来决定，定义位置： ，如：
typedef  CPU_INT32U  CPU_DATA;  数组元素是32位无符号整型，一个元素包含32个表项
typedef  CPU_INT16U  CPU_DATA;  数组元素是16位无符号整型，一个元素包含16个表项
typedef  CPU_INT8U  CPU_DATA;   数组元素是8位无符号整型，一个元素包含8个表项
表项	映射表的表项是1bit的数据；那么一个元素包含n个表项；
如CPU_DATA是32位的，那么数组的一个元素包含32个表项
一个表项代表一个优先级，1bit的数据只有0或1两个取值：
0：该优先级下没有处于就绪态的任务；
1：该优先级下的任务中至少有一个是就绪的；
一旦某个任务就绪，那么映射表中这个任务的优先级对应的那一位就会置1，如果该位已经置1，那就保持不变
OSPrioTb[0]的最高位表示最高优先级0
最低优先级OS_CFG_PRIO_MAX–1 由 OSPrioTb[OS_PRIO_TBL_SIZE–1]的某一位表示
容量	OSPrioTbl数组容量是OS_PRIO_TBL_SIZE；定义位置：os.h
那么就绪优先级位映射表的表项个数就是优先级的总个数
优先级总个数：OS_CFG_PRIO_MAX ，定义位置：os_cfg.h
OS_CFG_PRIO_MAX与OS_PRIO_TBL_SIZE的关系：
OS_CFG_PRIO_MAX = (OS_PRIO_TBL_SIZE–1) * n + x ，0≤x≤n

计算前导零
指令	就绪优先级位映射表用于查找最高优先级，查找方法是使用计算前导0指令
扫描就绪优先级位映射表：从OSPrioTb[0]的开始到OSPrioTb[OS_PRIO_TBL_SIZE–1]，
定义一个变量prio表示当前所有就绪的任务中的最高优先级；在扫描开始时prio初始化为0
扫描过程：
注意扫描过程是逐项扫描，即以数组元素为单位，而不是以bit为单位；
每当遇到一个为0的项，程序就会增加prio的值，然后继续往下扫描，
prio的增量是映射表数组元素的位宽，如映射表数据类型是CPU_INT16U，那么增量就是16；
一旦遇到一个非0项，那么扫描结束，本次扫描不增加prio的值
计算本次扫描项的前导零的数目，再加上prio的值，结果就是所有就绪任务中的最高优先级；
 	例如：
32位的数0xF000 0010，前导零数目是0，假如它就是OSPrioTb[0]的值，那么prio=0，
那么所有就绪任务中的最高优先级就是0；
8位的数0x00F1，前导零的数目是8，假如他是0SPrioTb[3]的值，
那么前面扫描了3个项：0SPrioTb[0]、0SPrioTb[1]、0SPrioTb[2]，prio的值为24
那么所有就绪任务中的最高优先级是24+8=32




OS_PrioGetHighest	输出	OS_PRIO变量	返回就绪的最高优先级
 	使用	
OS_PrioInsert	输入	OS_PRIO变量	输入一个优先级
 	使用	根据输入的优先级，找到它在就绪优先级位映射表中对应的表项，置1
OS_PrioRemove	输入	OS_PRIO变量	输入一个优先级
 	使用	根据输入的优先级，找到它在就绪优先级位映射表中对应的表项，清0


### 任务就绪表
定义	一个优先级对应一个任务就绪表，对应一个OSRDYLIST类型的变量，任务就绪表是一个双向链表
使用一个OSRDYLIST类型的变量就可以表示一个任务就绪表；
OSRDYLIST是一个结构类型定义，
某个优先级下仅有一个任务时，则TailPtr 和 HeadPtr指向同一个控制块
最低优先级OSRdyList[OS_CFG_PRIO_MAX–1]，它的这两个指针永远指向NULL
 	成员	数据类型	说明
 	 HeadPtr	OS_TCB指针	本任务就绪表的头部任务控制块的地址，
如果表中只有一个任务，那么HeadPtr就指向该任务
 	TailPtr	OS_TCB指针	本任务就绪表的尾部任务控制块的地址
如果表中只有一个任务，那么TailPtr就指向该任务
 	NbrEntries	OS_OBJ_QTY
变量	表示该优先级下就绪任务的数量；即该任务就绪表中成员的数目
举例：最低优先级固定且唯一分配给了空闲任务，
所以OSRdyList[OS_CFG_PRIO_MAX –1].NbrEntries=1
表项	一个优先级对应一个任务就绪表，该优先级下的所有就绪任务的任务控制块构成这个任务就绪表
也就是说任务就绪表是由任务控制块组成的；
容量	一个任务就绪表的容量就是：该优先级下的 就绪的 任务 的个数
链接	如：某个任务就绪表OSRdyList[n] (0<n<OS_CFG_PRIO_MAX–1 )；
由此得到：优先级n的任务就绪表：
表中任务的总数(即优先级为n的任务总数)：OSRdyList[n]. NbrEntries
表头任务控制块地址：OSRdyList[n]. HeadPtr
第2个任务控制块地址：(OSRdyList[n]. HeadPtr)->NextPtr
第3个任务控制快地址：((OSRdyList[n]. HeadPtr)->NextPtr)->NextPtr
……
表尾任务控制块地址：OSRdyList[n]. TailPtr
假设优先级为n的任务总共就只有4个，那么：
(((OSRdyList[n]. HeadPtr)->NextPtr)->NextPtr)->NextPtr=OSRdyList[n]. TailPtr
创建
任务
就绪表	任务就绪表由系统创建
在系统中创建了一个OSRDYLIST类型的数组OSRdyList[OS_CFG_PRIO_MAX]；定义位于文件os.h
OS_CFG_PRIO_MAX是优先级的总数，也是这个数组的容量；定于位于文件os.h
OSRdyList[0]对应的是最高优先级0
OSRdyList[OS_CFG_PRIO_MAX –1]对应最低优先级OS_CFG_PRIO_MAX–1
数组的每一个元素对应系统的一个优先级，元素的索引号就是对应的优先级：
每个优先级对应一个任务就绪表，有多少个优先级，就有多少个任务就绪表
那么一个系统中包含有OS_CFG_PRIO_MAX个任务就绪表
 	OS_RdyListInit	初始化并清空系统中所有的任务就绪表
编辑
任务
就绪表	将一个任务插入到任务就绪表，准确来说是进入任务就绪表中的某一个优先级双向链表中的某一个位置；
任务在进入就绪态之前，其优先级是确定的；因此根据任务的优先级将其插入到相应的双向链表中；
 	OS_RdyListRemove	输入	OS_TCB指针	要移除的任务控制块的地址
 	 	使用	
 	OS_RdyListInsert	输入	OS_TCB指针	要插入的任务控制块的地址
 	 	使用	
 	OS_RdyListInsertHead	输入	OS_TCB指针	要插入的任务控制块的地址
 	 	使用	将该任务插入到 其优先级对应的的任务就绪表 的首部
 	OS_RdyListInsertTail	输入	OS_TCB指针	要插入的任务控制块的地址
 	 	使用	将该任务插入到 其优先级对应的的任务就绪表 的尾部
 	OS_RdyListMoveHeadToTail	输入	OS_RDY_LIST指针	要移动的任务控制块的地址
 	 	使用	







## 任务等待
任务等待态
处于等待态的任务不占用CPU，位于任务等待表中(wait list)
处于等待态意味着该任务在被恢复之前不能取得CPU的使用权。

### 任务挂起
被挂起的任务可以向其他任务发信号和消息，或与其他任务共享资源等等。
即任务除了可以调用“等待某个事件”的函数，也可以根据需要调用其他的服务函数
注意，延时等待任务也能够被挂起。这种情况下，挂起效果累加：
延时到一半时，被挂起，那么等到挂起操作被撤销，然后再等待剩余的一半延时时间，延时才结束。
一个正在等待某个事件发生 的任务，也能被挂起。
那么也是：要等到挂起操作被撤销，然后再判断事件是否发生发生或是否等待超时，任务才可以重新运行。

### 等待态就绪态
	删除一个内核对象
当删除一个内核对象
 	注意任务不可能直接从等待态进入运行态，一定是要先经过就绪态！任务等待的事件发生了（也就是说，一个任务或ISR执行了相对应post函数）
当  
或者当等待的事件对象被删除
或者当其他任务决定中止该等待过程
该等待过程就会结束
任务被重新放回任务就绪表中，然后再回到进入运行态前的第一步。
一个任务可以在指定的一段时间内等待某个时间发生。如果该事件内事件没有发生，则该任务也会进入就绪态；且会通知该任务等待超时了。



OSTaskSuspend	输入	OS_TCB指针	
 	 	OS_ERR指针	
 	输出	OS_ERR
变量赋值	
 	使用	使能：OS_CFG_TASK_SUSPEND_EN 置1，位置：
使用OSTaskSuppend()可以可无条件阻塞一个任务的运行，即挂起一个任务，被挂起的任务进入等待态，但这个任务实际上并没有等待某个事件的发生。只有通过调用另外一个函数OSTaskResume()，才能使被阻塞的任务恢复。
如果一个任务被挂起来了，必须交给其他的任务来恢复。
OS_TaskSuspend	输入	OS_TCB指针	
 	 	OS_ERR指针	
 	输出	OS_ERR
变量赋值	
 	使用	#if OS_CFG_TASK_SUSPEND_EN > 0u
OSTaskResume	输入	OS_TCB指针	
 	 	OS_ERR指针	
 	输出	OS_ERR
变量赋值	
 	使用	使能：OS_CFG_TASK_SUSPEND_EN置1，位置：
OSTaskResume()是恢复挂起任务的唯一办法
OS_Pend	输入	OS_PEND_DATA指针	
 	 	OS_PEND_OBJ指针	
 	 	OS_STATE变量	
 	 	OS_TICK变量	
 	输出		
 	使用	
OS_PendAbort	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	CPU_TS变量	
 	输出		
 	使用	
OS_PendAbort1	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	CPU_TS变量	
 	输出		
 	使用	
OS_PendObjDel	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	CPU_TS变量	
 	输出		
 	使用	
OS_PendObjDel1	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	CPU_TS变量	
 	输出		
 	使用	
OS_Post	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	void指针	
 	 	OS_MSG_SIZE变量	
 	 	CPU_TS变量	
 	输出		
 	使用	
OS_Post1	输入	OS_PEND_OBJ指针	
 	 	OS_TCB指针	
 	 	void指针	
 	 	OS_MSG_SIZE变量	
 	 	CPU_TS变量	
 	输出		
 	使用	
任务挂起表
定义	任务挂起表是内核对象的任务挂起表
一个内核对象对应一个任务挂起表，对应一个OS_PEND_LIST类型的变量，任务挂起表是一个双向链表
使用一个OS_PEND_LIST类型的变量就可以表示一个任务挂起表；OS_PEND_LIST是一个结构类型定义：
 	OS_PEND_LIST	成员	数据类型	说明
 	 	 HeadPtr	OS_PEND_DATA指针	本任务挂起表的头部挂起项的地址
 	 	TailPtr	OS_PEND_DATA 指针	本任务挂起表的尾部挂起项的地址
 	 	NbrEntries	OS_OBJ_QTY变量	表示等待该对象的任务的数量；也是该任务挂起表中挂起项的数目
链接	如：创建了某个信号量MySem，(OS_SEM  MySem);
那么它的的任务挂起表是MySem->PendList，由此得到：
 	表中挂起项的总数：MySem->PendList. NbrEntries
表头挂起项地址：MySem->PendList. HeadPtr
第2个挂起项地址：(MySem->PendList. HeadPtr)->NextPtr
第3个挂起项地址：((MySem->PendList. HeadPtr)->NextPtr)->NextPtr
……
表尾挂起项地址：MySem->PendList. TailPtr
假设等待该信号量的任务总共就只有4个，那么：
(((MySem->PendList. HeadPtr)->NextPtr)->NextPtr)->NextPtr=MySem->PendList. TailPtr
 	等待该信号量的任务总数：MySem->PendList. NbrEntries
表头任务控制块地址：(MySem->PendList. HeadPtr)->TCBPtr
第2个任务控制块地址：((MySem->PendList. HeadPtr)->NextPtr)->TCBPtr
第3个任务控制快地址：((MySem->PendList. HeadPtr)->NextPtr)->NextPtr)>TCBPtr
……
表尾任务控制块地址：(MySem->PendList. TailPtr)>TCBPtr
假设优先级为n的任务总共就只有4个，那么：
((((MySem->PendList. HeadPtr)->NextPtr)->NextPtr)->NextPtr )>TCBPtr= (MySem->PendList. TailPtr)>TCBPtr
表项	等待某个内核对象的的所有任务挂起项构成一个任务挂起表
这就是前面讲到的“一个内核对象对应多个任务挂起项”的情况；
和任务就绪表不同，任务挂起表的成员不是任务控制块，而是OS_PEND_DATA类型的变量；
我称之为任务挂起项；挂起项的作用只有一个：就是作为任务挂起表的成员而存在
当一个任务等待某个内核对象时，就会产生一个任务挂起项
注意：从上面这个语句可以看出，任务挂起项包含两个确认的元素：某个任务、某个内核对象
所以任务挂起项的成员就需要包含这两个元素
某个任务：使用成员TCBPtr指向某个确定的任务，因为前面已经说过任务和任务控制块是一一对应的。
某个内核对象：使用成员PendObjPtr指向系统中某个确定的内核对象；详见OS_PEND_OBJ数据类型
 	一个任务挂起项对应一个任务
一个任务挂起项对应一个内核对象
但是：
一个任务可以对应多个任务挂起项：这些任务挂起项的TCBPtr成员相同，但PendObjPtr成员不同
这就是一个任务同时等待多个内核对象的情况；
一个内核对象可以对应多个任务挂起项：这些任务挂起项的PendObjPtr成员相同，但TCBPtr成员不同
这就是一个内核对象同时被多个任务等待的情况；
 	OS_PEND_OBJ	成员	数据类型	说明
 	 	PrevPtr	OS_PEND_DATA指针	表示在任务挂起表中，本挂起项的前一个挂起项的地址
 	 	NextPtr	OS_PEND_DATA指针	表示在任务挂起表中，本挂起项的下一个挂起项的地址
 	 	TCBPtr	OS_TCB指针	本挂起项对应的任务控制块的地址
 	 	PendObjPtr	OS_PEND_OBJ指针	本挂起项对应的内核对象头的地址
 	 	RdyObjPtr	OS_PEND_OBJ指针	本挂起项对应的内核对象发布前：*.RdyObjPtr=0
本挂起项对应的内核对象发布后：*.RdyObjPtr=*.PendObjPtr
用于标识本挂起项对应的内核对象是否发布
 	 	RdyMsgPtr	void指针	如果本挂起项对应的内核对象是一个消息队列；
那么每当其对应的任务从该消息队列收到一条消息，
RdyMsgPtr成员就会更新，表示这条消息的地址
如果该消息队列为空：那么RdyMsgPtr=0
 	 	RdyMsgSize	OS_MSG_SIZE变量	如果本挂起项对应的内核对象是一个消息队列；
那么每当其对应的任务从该消息队列收到一条消息，
RdyMsgSize成员就会更新，表示这条消息的大小；
如果该消息队列为空：那么RdyMsgSize=0
 	 	CPU_TS	CPU_TS变量	本挂起项对应的内核对象发布前：*.CPU_TS=0
本挂起项对应的内核对象发布后：*.CPU_TS=发布时刻的时间戳
用于记录本挂起项对应的任务所等待的内核对象释放的时刻




挂起表的表头	指向等代表中优先级最高的任务。
注意HeadPtr虽然是指向一个任务，但并不是指向某个任务的任务控制块0S_TCB，而是指向一个OS_PEND_DATA结构类型的变量。
OS_PEND_DATA结构类型定义的内容比OS_TCB更加丰富。
因为该结构的成员中有成员：OS_TCB*   TCBPtr   ，它包含一个任务控制块
除此以外还包含该任务所等待的内核对象的信息
挂起表的表尾	指向等代表中优先级最低的任务
	
	



OS_PendListInit	输入	OS_PEND_LIST
指针	
 	输出	无	
 	使用	
OS_PendDataInit	输入	OS_TCB
指针	
 	 	OS_PEND_DATA
指针	
 	 	OS_OBJ_QTY
变量	
 	输出	无	
 	使用	


查看OS_SEM、OS_MUTEX、OS_FLG_GRP、OSQ这4个用于定义内核对象的数据结构类型，可以发现他们都包含有PendList成员；
当上述中的某个内核对象被创建，会伴随地创建一个任务挂起表，所以每一个内核对象都对应有一个任务挂起表
当任务在等待某个内核对象的时候，该任务就会会进入所等待的对象的任务挂起表；


OS_PendDbgNameAdd	输入	OS_PEND_OBJ
指针	
 	 	OS_TCB
指针	
 	输出	无	
 	使用	#if OS_CFG_DBG_EN > 0u

OS_PendDbgNameRemove	输入	OS_PEND_OBJ
指针	
 	 	OS_TCB
指针	
 	输出	无	
 	使用	#if OS_CFG_DBG_EN > 0u

OS_PendListGetPtr	输入	OS_PEND_OBJ
指针	
 	输出	OS_PEND_LIST
指针	
 	使用	
OS_PendListInsertHead	输入	OS_PEND_LIST
指针	
 		OS_PEND_DATA
指针	
 	输出	无	
 	使用	
OS_PendListInsertPrio	输入	OS_PEND_LIST
指针	
 		OS_PEND_DATA
指针	
 	输出	无	
 	使用	
OS_PendListChangePrio	输入	OS_TCB
指针	
 	输出	无	
 	使用	
OS_PendListRemove	输入	OS_TCB
指针	
 	输出	无	
 	使用	
OS_PendListRemove1	输入	OS_PEND_LIST
指针	
 		OS_PEND_DATA
指针	
 	输出	无	
 	使用	


两个任务等待同一个信号量
还是从最简单的开始，多个任务等待一个内核对象的情况在前面已经出现过很多次，这里再深入地分析一下
优先级：A>B
创建信号量a
	1.创建一个OS_SEM类型的变量作为信号量
2.使用函数OSSemCreate()
初始化信号量时，需要将信号量的初始值设为0，那么信号量被创建，但是是无效的
创建任务A
进入运行态	任务A创建后，先进入就绪态，因为优先级最高，进入
创建任务B	在任务A的程序中，创建一个任务B，任务B的优先级比A低，任务B进入就绪态，任务A继续运行态
任务A请求信号量a	任务A使用OSSem_Pend()请求信号量a，此时系统中没有信号量a（无效）。
任务A进入等待态

（系统自动创建）表示任务A和信号量a的OS_PEND_DATA结构类型变量：OS_PEND_DATA_A
––PrevPtr=0  因为信号量a的等待列表中只有一个任务，PrevPtr指向NULL
––NextPtr=0  因为信号量a的等待列表中只有一个任务，NextPtr指向NULL
––TCBPtr 因为是在任务A的程序中使用OSSem_Pend()函数，所以OS_PEND_DATA_A的TCBPtr会指向任务A的任务控制块。
––PendObjPtr 因为使用OSSem_Pend()函数时会传递信号量a的地址，所以OS_PEND_DATA_A的PendObjPtr指向一个表示信号量a的  OS_PEND_OBJ结构类型的 变量。

信号量a的PendList的3个成员：
HeadPtr  =  & OS_PEND_DATA_A 
TailPtr    =   & OS_PEND_DATA_A 
NbrEntries=1   信号量a的等待列表中只有1个任务

任务B进入运行态
任务B请求信号量a	任务B使用OSSem_Pend()请求信号量a，此时系统中没有信号量a（无效）。
任务B进入等待态

表示任务A和信号量a的OS_PEND_DATA结构类型变量：OS_PEND_DATA_A
––PrevPtr=0  因为信号量a的等待列表中没有比OS_PEND_DATA_A优先级更高的任务
––NextPtr= &OS_PEND_DATA_B  
––TCBPtr 因为是在任务A的程序中使用OSSem_Pend()函数，所以OS_PEND_DATA_A的TCBPtr会指向任务A的任务控制块。
––PendObjPtr 因为使用OSSem_Pend()函数时会传递信号量a的地址，所以OS_PEND_DATA_A的PendObjPtr指向一个表示信号量a的  OS_PEND_OBJ结构类型的 变量。

（系统自动创建）表示任务B和信号量a的OS_PEND_DATA结构类型变量：OS_PEND_DATA_B
––PrevPtr=&OS_PEND_DATA_A  
––NextPtr=0  因为信号量a的等待列表中没有比OS_PEND_DATA_B优先级更低的任务
––TCBPtr 因为是在任务B的程序中使用OSSem_Pend()函数，所以OS_PEND_DATA_B的TCBPtr会指向任务B的任务控制块。
––PendObjPtr 因为使用OSSem_Pend()函数时会传递信号量a的地址，所以OS_PEND_DATA_B的PendObjPtr指向一个表示信号量a的  OS_PEND_OBJ结构类型的 变量。

信号量a的PendList的3个成员：
HeadPtr  =  & OS_PEND_DATA_A 
TailPtr    =   & OS_PEND_DATA_B 
NbrEntries=1   信号量a的等待列表中有2个任务











### 对象等待表
定义	对象等代表是任务的对象等代表
一个任务对应一个对象等待表，对应一个OS_PEND_DATA类型的数组
该任务所等待的所有内核对象：该任务等待内核对象a；该任务等待内核对象b；该任务等待内核对象c；……
上述每一对都对应一个任务挂起项，由这些任务挂起项组成该任务的对象等代表。
这就是前面讲到的“一个任务对应多个任务挂起项”的情况；

当一个任务要等待多个内核对象时，它就会创建一个对象等代表来进行管理：这一步是由用户自己完成的；
创建并初始化一个对象等代表：

OSPendMulti	输入	OS_PEND_DATA
指针	对象等待表的首地址

 	 	OS_OBJ_QTY
变量	传递第一个参数中，OS_PEND_DATA结构类型数组的容量
 	 	OS_TICK
变量	设置一个超时等待值，单位是时钟节拍
如果timeout=0，则会一直等下去。
 	 	OS_OPT
变量	OS_OPT_PEND_FLAG_MASK	
 	 	 	OS_OPT_PEND_FLAG_CLR_ALL	
 	 	 	OS_OPT_PEND_FLAG_CLR_AND	
 	 	 	OS_OPT_PEND_FLAG_CLR_ANY	
 	 	 	OS_OPT_PEND_FLAG_CLR_OR	
 	 	 	OS_OPT_PEND_FLAG_SET_ALL	
 	 	 	OS_OPT_PEND_FLAG_SET_AND	
 	 	 	OS_OPT_PEND_FLAG_SET_ANY	
 	 	 	OS_OPT_PEND_FLAG_SET_OR	
 	 	 	OS_OPT_PEND_FLAG_CONSUME	
 	 	 	OS_OPT_PEND_BLOCKING	阻塞型：如果没有相应的信号量，该任务任务进入等待态，直到信号量被释放或超时
 	 	 	OS_OPT_PEND_NON_BLOCKING	非阻塞型：如果没有相应的信号量，那么这个任务将立即返回不再等待，并且返回错误信息说明此事信号量无效。
显然它要求在使用OSSemPend()前就有相应的信号量，即相应的信号量一直是有效的，
这实现不了共享资源的作用，这个选项一般不会用。
 	 	OS_ERR
指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_OBJ_QTY
变量	
 	 	OS_ERR
变量
赋值	
 	使用	#if OS_CFG_PEND_MULTI_EN > 0u
之前我们所使用的用来请求内核对象的函数有两个局限性：
1.只能请求某个指定的内核对象，如OSSemPend只能请求信号量，OSQPend只能请求消息队列……
2.每次使用请求内核对象的函数只能请求一个内核对象。
当一个任务要同时等待多个内核对象时，就需要使用到OSPendMulti()函数。

当被调用时，函数首先验证传递给函数的OS_PEND_DATA类型的数组的元素是否都是OS_SEM或OS_Q（不可以是OS_MUTEX或OS_FLAG_GRP）

然后遍历数组中所有的元素，确定是否有任何一个对象已经被发布了，根据其结果配置数组元素的结构。
如果数组中没有任何对象发布，那么OSPendMulti()函数就会把当前任务放置在当前任务所等待的内核对象的等代表中。由于在当前任务正在等待的某些内核对象的带代表中可能还会有其他的任务也在等待，所以这对OSPendMulti()来说将是一项复杂而且冗长的过程。



μC/OS允许一个任务同时等待多个信号量，允许一个任务同时等待多个消息队列，允许一个任务同时等待多个信号量和多个消息队列。
μC/OS不允许同时等待多个事件标志组，不允许同时等待多个互斥信号量，不允许同时等待1个互斥信号量加其他任何内核对象，不允许同时等待1个事件标志组加其他任何内核对象

函数名：OSPendMulti()
之前我们所使用的用来请求内核对象的函数有两个局限性：
1.只能请求某个指定的内核对象，如OSSemPend只能请求信号量，OSQPend只能请求消息队列……
2.每次使用请求内核对象的函数只能请求一个内核对象。
当一个任务要同时等待多个内核对象时，就需要使用到OSPendMulti()函数。



OS_PendMultiGetRdy	输入	OS_PEND_DATA
指针	
 	 	OS_OBJ_QTY
变量	
 	输出	OS_OBJ_QTY	
 	使用	
OS_PendMultiValidate	输入	OS_PEND_DATA
指针	
 	 	OS_OBJ_QTY
变量	
 	输出	CPU_BOOLEAN	
 	使用	
OS_PendMultiWait 	输入	OS_PEND_DATA
指针	
 	 	OS_OBJ_QTY
变量	
 	 	OS_TICK
变量	
 	输出	无	
 	使用	



当被调用时，函数首先验证传递给函数的OS_PEND_DATA类型的数组的元素是否都是OS_SEM或OS_Q（不可以是OS_MUTEX或OS_FLAG_GRP）

然后遍历数组中所有的元素，确定是否有任何一个对象已经被发布了，根据其结果配置数组元素的结构。
如果数组中没有任何对象发布，那么OSPendMulti()函数就会把当前任务放置在当前任务所等待的内核对象的等代表中。由于在当前任务正在等待的某些内核对象的带代表中可能还会有其他的任务也在等待，所以这对OSPendMulti()来说将是一项复杂而且冗长的过程。





一个任务同时等待两个信号量

创建信号量a
和信号量b
	1.创建2个OS_SEM类型的变量作为信号量a和信号量b
2.使用函数OSSemCreate()
初始化信号量时，需要将信号量的初始值设为0，那么信号量a和信号量b被创建，但都是无效的
创建OS_PEND_DATA数组	创建数组my_pend_data[2]，初始化这个数组
这个数组包含两个OS_PEND_DATA结构类型的元素
初始化时将这两个元素的PendObjPtr成员分别指向信号量a和信号量b
创建任务A	任务A进入运行态
任务A同时请求两个信号量	使用OSPendMulti()函数，同时请求信号量a和信号量b。
此时系统中没有信号量a和信号量b（无效）。任务A进入等待态。

在前面一小节中两个任务等待一个信号量时，创建了两个OS_PEND_DATA结构类型变量：OS_PEND_DATA_A和OS_PEND_DATA_B，它们表示同一个信号量，也表示两个不同的任务
在本例中，也创建了两个OS_PEND_DATA结构类型变量：
my_pend_data[0]和my_pend_data[1]，它们表示同一个任务，也表示两个不同的信号量


表示任务A和信号量a的OS_PEND_DATA结构类型变量：my_pend_data[0]
––PrevPtr=0  因为信号量a的等待列表中只有一个任务，PrevPtr指向NULL
––NextPtr=0  因为信号量a的等待列表中只有一个任务，NextPtr指向NULL
––TCBPtr 因为是在任务A中使用OSPendMulti()函数，所以传递给OSPendMulti()函数的数组元素my_pend_data[0]和my_pend_data[1]的TCBPtr都会指向任务A的任务控制块。
––PendObjPtr 初始化时已经给my_pend_data[0]的PendObjPtr赋值
––RdyObjPtr =0 此时所等待的内核对象还没有释放

表示任务A和信号量b的OS_PEND_DATA结构类型变量：my_pend_data[1]
––PrevPtr=0  因为信号量b的等待列表中只有一个任务，PrevPtr指向NULL
––NextPtr=0  因为信号量b的等待列表中只有一个任务，NextPtr指向NULL
––TCBPtr 因为是在任务A中使用OSPendMulti()函数，所以传递给OSPendMulti()函数的数组元素my_pend_data[0]和my_pend_data[1]的TCBPtr都会指向任务A的任务控制块。
––PendObjPtr 初始化时已经给my_pend_data[1]的PendObjPtr赋值
––RdyObjPtr =0 此时所等待的内核对象还没有释放

信号量a的PendList的3个成员：
HeadPtr  =  & my_pend_data[0] 
TailPtr    =   & my_pend_data[0]
NbrEntries=1  信号量a的等待列表中只有1个任务

信号量b的PendList的3个成员：
HeadPtr      my_pend_data[1]
TailPtr        my_pend_data[1]
NbrEntries=1   信号量a的等待列表中只有1个任务

进入中断服务程序	释放信号量a
任务A获取信号量a	
进入中断服务程序	释放信号量b
任务A获取信号量b	
任务A进入运行态	任务A的请求得到响应，两个信号量都获取而进入就绪态，任务A的优先级最高进入运行态



### 多个任务等待多个信号量
有两个任务，其中一个任务在等待两个信号量，另一个任务也在等在这两个信号量中的一个。


## 任务调度

### 调度器
任务
调度	扫描此刻的任务就绪表，找到优先级最高的任务，确定作为接下来执行的任务，这就是任务调度
执行任务调度的程序称为调度程序，又称为任务调度器。
调度程序并不是一直执行的，它需要触发源（调度点），即只有当发生了某一些特定的事件，才能启动调度器。
假设某一个任务此刻正在执行中，
既然正处于执行中，根据可剥夺型内核的特点我们可以知道：此刻任务就绪表中没有哪个任务的优先级比正在执行的任务的高
发生以下事件将触发调度
调度器	OSSched	OSSched()函数是在任务程序中执行。定义在文件os_core.c
该函数启动时先进行检查，确保其不是从中断服务程序中被调用的，因为本函数是任务级的调度器；
接下来确认调度器没有上锁。如果程序调用了OSSchedLock()，那么意味着用户并不想启动调度器，这时本函数直接返回
该函数通过扫描就绪优先级位映射表来确定处于就绪优先级最高的任务的优先级
一旦找到有任务就绪的最高优先级，用优先级作为索引找到其对应的任务就绪表，从该表的头部便可获得最高优先级任务的任务控制块
如果就绪的最高优先级的任务不是当前任务，那么将进行一次任务级的任务切换
 	OSIntExit	OSIntExit()函数是在中断服务函数程序中执行。定义在文件os_core.c
确保其不是从任务中被调用的，因为本函数是在中断服务函数程序中执行的调度器；
调用该函数时，中断应该是禁止的；
该函数启动时先进行检查OSIntNestingCtr，确保其不会向下溢出。
因为该函数时中断服务程序结束时被调用的，因此本函数将中断嵌套计数器OSIntNestingCtr减1，如果还是没有退出所有的中断嵌套，那么本函数直接返回，因为在仍然返回到中断服务程序的情况下，没有必要启动调度器，
检查调度器是否上锁；如果程序调用了OSSchedLock()，那么意味着用户并不想启动调度器，这时本函数直接返回到被中断的任务，也就是锁住调度器的任务
如果这是最后一层中断(也就是说再返回到任务级了)，并且调度器没有上锁，那么OSIntExit()将找出就绪的最高优先级的任务。
如果就绪的最高优先级的任务不是当前任务，那么将进行一次中断级的任务切换
调度器
上锁
与
解锁	执行函数	OSSchedLock	调度器上锁，没有输入，没有输出
 	 	OSSchedUnlock	调度器解锁，没有输入，没有输出
 		OS_CFG_ISR_POST_DEFERRED_EN置1时，系统在进入临界段代码前会给调度器上锁，并在退出临界段代码后给调度器解锁。

 		如果某项任务不需要和ISR共享变脸过数据结构，那么可以通过对调度器上锁然后再开锁来访问共享资源，通过该方法，两个甚至两个以上的任务可以共享数据而避免出现竞争。需要注意的是，如果调度器已经上锁了，但并没有关中断，那么一旦中断发生，即便在临界区内，中断服务程序也将被立即执行。
但即使由此而使得某些具有更高优先级的任务就绪了，在中断服务程序结束后，内核仍将返回至被中断的任务。在调度器上锁的情况下，中断服务程序总是返回至被打断的任务中去，此时内核的行为与那些不可剥夺内核十分相似；
这两个函数可以嵌套250层，如果上锁嵌套了多层，那么解锁也解锁相应的层数，系统才会答应调度请求。
 		调度器上锁时，系统禁止用户进行阻塞型调用
如果某些应用能够进行阻塞型调用，则该应用很可能已经崩溃了
 		虽然可以达到共享资源的目的，但显然“禁止任务调度”有悖于可剥夺型内核的初衷。一旦给调度器上锁，则当前的任务就直接被提升为具有最高优先级的任务了。
 		
 		只有当调度器解锁后，ucOS系统才会在调度点进行调度




OS_Sched	输入	无	
 	输出	无	
 	使用	#if OS_CFG_ISR_POST_DEFERRED_EN > 0u

OS_SchedLockTimeMeasStart	输入	无	
 	输出	无	
 	使用	#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u

OS_SchedLockTimeMeasStop	输入	无	
 	输出	无	
 	使用	#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u



### 调度点
当前运行的任务
当前运行
的任务	将自己删除	
 	改变优先级	改变自身的优先级或其他任务的优先级
这时出现了新的优先级顺序，重新查看所有任务的优先级（当前正在执行的任务和任务就绪表中的任务），如果任务就绪表中有任务比当前任务的优先级高，那么就会启动任务调度器。
当前运行
的任务
进入等待态	调用延时函数OSTimeDly()或OSTimeDlyHMSM()
 	使用OS……Pend函数请求内核对象
 	使用OSTaskSuspend函数将自身挂起
当前运行
的任务
召唤其他任务	使用OS…PendAbort函数取消另一个任务的等待状态，被取消等待的任务直接进入就绪态，参与任务调度
 	使用OS…Post函数发布一个内核对象给处于等待态的任务，要求处于等待态的任务允许调度
 	使用OS…Del删除一个内核对象
 	使用OSTaskCreate函数创建一个新的任务
操控
调度器	调用OSSchedUnLock()函数解锁调度器
通过给调度器上锁操作是可以嵌套的，解锁时也必须执行和上锁操作相同次数的解锁操作。
 	调用OSSched()函数启动调度器。
这主要用在  执行post函数时指定OS_OPT_POST_NO_SCHED 选项的情况，这样可以实现多次发布操作后才进行一次任务调度，而不用每次发布后都执行以便调度器。
上述情况也可以在最后一次发布操作中不使用OS_OPT_POST_NO_SCHED选项，效果是等价的
发生中断	当嵌套的中断执行完毕后，会重新检查当前任务的优先级和任务就绪表中任务的优先级。
如果有比当前任务的优先级更高的任务进入就绪态，则启动调度器
任务放弃其执行的时间片
这种情况的前提是在同一优先级下有多个任务，正在运行的任务放弃其未完的时间片，从未让另一个同优先级的任务执行，详见时间片轮转调度


(即该任务使用OS……Pend函数请求内核对象时没有选择OS_OPT_POST_NO_SCHED)
时间片轮转调度
μC/OS–III允许一个任务运行一段指定的时间（又叫时间片），然后轮到下一个任务。这个过程叫做时间片轮转调度，或时间分片调度。

系统允许用户在运行时使能或禁止时间片轮转调度

用户可以设定时间片是n个时钟节拍。
那么同一个优先级的所有任务轮流运行，每次运行n个时钟节拍。

如果有一个任务运行时，还没有用完它的时钟节拍时，调用OSSchedRoundRobinYeild()函数，那么意味着它将放弃剩余的x个（x<n）时钟节拍，那么直接轮到下一个任务运行，且这下一个任务运行时重新计数，仍然运行n个时钟节拍。

系统允许用户为每个任务制定不同的时间片。
任务的时间片在创建任务的时候设定，运行时也可以用OSTaskTimeQuantaSet()函数来改变。



OS_SchedRoundRobin	输入	OS_RDY_LIST指针	
 	使用	使能：OS_CFG_SCHED_ROUND_ROBIN_EN 置1，定义位置：
如果当前任务的时间片已经运行完，而且在同一优先级下有多个任务，那么ucOS系统将会切换到该优先级对应的下一个就绪任务。
该操作是通过本函数来实现的
本函数由OSTimeTick()函数或OS_IntQTask()调用，
如果选择直接发布，本函数由OSTimeTick()函数调用，
如果选择延迟发布，本函数由OS_IntQTask()函数调用，
 	 	函数首先检查时间片轮转调度是否允许，前面提到，要允许时间片轮转调度，程序要调用
OSSchedRoundRobinCfg()
将时间片计数器减1，该变量位于任务的控制块中，如果该变量没有减到0，那么本函数直接返回；
如果时间片计数器已经减到0，那么本函数会检查当前优先级下是否有其他的就绪任务。如果没有，则函数直接返回。因为时间片轮转调度仅用于多个任务运行在同一个优先级下，而且任务在单个时间片内无法完成其工作的情况
如果调度器上锁，本函数直接返回
接着，本函数将当前任务的控制块从任务就绪表的头部移到尾部
然后，任务就绪表首部的任务的时间片的值将被载入，每一个任务在建立的时候都可以指定其时间片的值，也可以通过OSTaskTimeQuantaSet()函数来改变
如果时间片的值是0，那么系统会使用默认的值，默认值是OSSchedRoundRobinDfltTimeQuanta

OSSchedRoundRobinCfg	输入	CPU_BOOLEAN
变量	
 	 	OS_TICK
变量	
 	 	OS_ERR
指针	
 	输出	OS_ERR
变量
赋值	
 	使用	#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
OSSchedRoundRobinYield	输入	OS_ERR
指针	
 	输出	OS_ERR
变量
赋值	
 	使用	#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
 	
 	

### 任务切换
OSTaskSwHook	输入	无	
 	输出		
 	使用	

任务级
OSCtxSw	对应任务级的任务调度
OSTCBCurPtr指向当前运行任务的任务控制块，也就是调用本函数的任务。
函数找到新的将要运行的任务，并将OSTCBHighRdyPtr指向该任务的任务控制块
OSTCBHighRdyPtr->StkPtr指向将要运行的新任务的堆栈栈顶
ucOS系统创建或挂起一个任务时，任务堆栈帧看起来总是和刚发生中断一样，所有寄存器都保存在里面。这些寄存器代表了任务的预期状态，因此任务也就可以得到恢复
接着，CPU的堆栈指针指向调用本函数的任务的任务栈区(在RAM中)，也可能指向本函数的返回地址，这取决于本函数的调用方式

执行任务切换时
本函数首先把当前的任务的状态寄存器和程序计数器保存到当前任务的堆栈中。寄存器入栈的顺序和中断发生时CPU将寄存器压入堆栈的顺序一样。这里假设状态寄存器SR先入栈，其余寄存器接着依次入栈。
接着，将CPU堆栈指针的当前值保存到将要停止运行的任务的控制块OS_TCB中，
也就是赋值操作：OSTCBCurPtr->StkPtr=R14
然后，将新任务的任务控制块中保存的该任务的堆栈指针的值载入到CPU的堆栈指针寄存器，该指针的值是在上一次该任务被切换时保存的，指向的是当时的任务堆栈的栈顶。即赋值操作：R14=OSTCBHighRdyPtr->StkPtr
最后，函数从新的堆栈中恢复CPU寄存器的值。程序计数器和状态寄存器通常是在执行中断返回指令时弹出堆栈的。
中断级
OSIntCtxSw	对应中断级的任务调度
ucOS系统假设在进入中断服务程序时CPU寄存器已经被保存到任务的堆栈中
因此，OSTCBCurPtr->StkPtr已经包含了指向正在挂起的那个任务的堆栈栈顶的指针，而本函数也就无需保存被挂起任务的CPU寄存器了，因为这部分工作已经完成了。
将新任务的任务控制块中保存的该任务的堆栈指针的值载入到CPU的堆栈指针寄存器，该指针的值是在上一次该任务被切换时保存的，指向的是当时的任务堆栈的栈顶。即赋值操作：R14=OSTCBHighRdyPtr->StkPtr
最后，函数从新的堆栈中恢复CPU寄存器的值。程序计数器和状态寄存器通常是在执行中断返回指令时同时被恢复的。




# 时间管理

## 时钟节拍
时钟节拍
时钟节拍	时钟节拍也称为系统节拍，作用就是延迟或超时的判断。
每次要进行延迟或超时判断时，就启动时钟节拍，时钟节拍发生了设定的次数后，则任务延迟结束或判定为超时。
使用一个硬件定时器产生周期性的时基中断，对应执行一次时基中断服务函数，时基中断服务函数又称为时基事件
时基中断服务函数会释放一个信号量以启动时钟节拍任务，释放信号量时可以直接发布也可以延迟发布
每一次时基中断意味着一个时钟节拍：
1次时基中断  一次时基事件 1个时钟节拍   一次时钟节拍任务
也有可能一个优先级更高的任务执行时发生时基中断，那么在时基中断结束后，系统会先恢复这个优先级更高的任务。如果出现这种情况，那么时钟节拍任务不会立即返回。这里就出现了时钟节拍的误差；

### 时钟节拍
频率	时钟节拍频率是OSCfg_TickRate_Hz，定义位置：os_cfg_app.c
取值：10~1000
单位：Hz	
时钟节拍的实际频率取决于具体应用对定是精度的要求
当需要较高的实时性即对精度要求很高的时候，就提高时钟节拍频率，但这么做也会增加系统的负荷；
实际使用的始终节拍频率和处理器的速度、期望达到的延时精度、以及处理时钟节拍定时器所允许的资源开销有关
时钟节拍
计数器	时钟节拍计数器是OS_TICK类型的变量OSTickCtr，定义位置：os.h
单位：时钟节拍
系统复位时，时钟计数器设置为0；
每经过一个时钟节拍，时钟节拍计数器值加1
时基中断	时基中断对应的中断服务函数是OS_CPU_SysTickHandler()
OS_CPU_SysTickHandler()函数会调用OSTimeTick()函数，由OSTimeTick()函数完成大部分的时钟节拍处理工作；



OSTickTaskTimeMax	CPU_TS
变量	


### 时钟节拍服务
OSTimeDly
延时
指定
时钟节拍	输入	OS_TICK
变量	相对模式	表示延时的时间长度，单位：时钟节拍
 	 	 	周期模式	表示一个周期的时间长度，单位：时钟节拍
 	 	 	绝对模式	表示延时的时间长度：单位：时钟节拍
 	 	OS_OPT
变量	OS_OPT_TIME_DLY	相对模式
从任务调用本函数的时刻算起，延时OS_TICK变量指定的时间
 	 	 	OS_OPT_TIME_MATCH	绝对模式
从上电的时刻算起，延时OS_TICK变量指示的时间
 	 	 	OS_OPT_TIME_PERIODIC	周期模式
从任务调用本函数的时刻算起，每经过一个周期，都会对该人物执行唤醒操作；
 	 	OS_ERR
指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	 	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OPT_INVALID	
 	 	 	OS_ERR_SCHED_LOCKED	
 	 	 	OS_ERR_TIME_DLY_ISR	
 	 	 	OS_ERR_TIME_ZERO_DLY	
使用
相对
模式	举例说明：(优先级：任务1>任务2)
 	时刻T1	发生第一个时钟节拍中断；
 	时刻T2	第一个时钟节拍任务执行完毕；同时开始执行任务1
 	时刻T3	任务1调用OSTimeDly()，指定延时1个时钟节拍，任务1进入等待状态，切换到任务2，开始执行任务2
 	时刻T4	任务2调用OSTimeDly()，指定延时2个时钟节拍，任务2进入等待状态
 	时刻T5	发生第二个时钟节拍中断；
 	时刻T6	第二个时钟节拍任务执行完毕，任务1进入运行状态，继续执行任务1
 	时刻T7	发生第三个时钟节拍中断；
 	时刻T8	第三个时钟节拍任务执行完毕，此时任务2本该进入运行态，但由于任务1正在执行且任务1的优先级高
所以任务2只能继续等待
 	时刻T9	任务1执行完毕，切换到任务2，任务2进入运行状态，继续执行；
 	说明：1个时钟节拍的延时Tick= T5 – T1 = T6 – T2 = T7 – T5 = T8 – T6
任务1：延时时间=T6 – T3 < Tick，因为调用OSTimeDly后，下一个时钟节拍可能马上到来，产生 0~1个时钟节拍的误差
任务2：延时时间=T9 – T4 > Tick，因为受到高优先级任务的影响，那没办法，谁叫你优先级低呢；
使用
周期
模式	时刻T1	发生第一个时钟节拍中断；
 	时刻T2	第一个时钟节拍任务执行完毕；同时开始执行任务1
 	时刻T3	任务1调用OSTimeDly()，指定周期为2个时钟节拍，任务1进入等待状态
切换到任务2，开始执行任务2
 	时刻T4	任务2调用OSTimeDly()，也指定周期为2个时钟节拍，任务2进入等待状态
 	时刻T5	发生第二个时钟节拍中断；
 	时刻T6	第二个时钟节拍任务执行完毕，
 	时刻T7	发生第三个时钟节拍中断；
 	时刻T8	第三个时钟节拍任务执行完毕，此刻任务1和任务2都可以进入运行态，但任务1的优先级高，
所以任务1进入运行态，任务2继续留在任务挂起表中；
 	时刻T9	任务1执行完毕；任务2继续处于等待状态，任务2只能在周期点被唤醒；
错过了一个周期点后，只能在下一个周期点被唤醒
 	时刻T10	发生第四个时钟节拍中断；
 	时刻T11	第四个时钟节拍任务执行完毕，此刻仍然不是任务2的周期点，所以继续等待
 	时刻T12	发生第五个时钟节拍中断；
 	时刻T13 	第五个时钟节拍任务执行完毕，到达任务2的周期点，且此刻任务2的优先级最该，所以任务2进入运行态
使用
绝对
模式	绝对模式和相对模式类似，但其计算的时间是从上电后开始，假设设置OS_Tick是10个时钟节拍
在发生了5个时钟节拍后任务调用该函数，任务进入等待态，那么在第10个时钟节拍任务执行完毕的时刻，任务被唤醒；
在





OSTimeDlyHMSM
延时指定
具体时间	输入	CPU_INT16U变量	单位：小时	延时的时间长度，
延时的精度极大地取决于时钟节拍的频率OS_CFG_TICK_RATE_HZ  
OS_CFG_TICK_RATE_HZ=1000Hz：精度为1ms(即误差范围)
OS_CFG_TICK_RATE_HZ=100Hz：精度为10ms(即误差范围)
 	 	CPU_INT16U变量	单位：分	 
 	 	CPU_INT16U变量	单位：秒	 
 	 	CPU_INT32U变量	单位：毫秒	 
 	 	OS_OPT 
变量	模式
选择	OS_OPT_TIME_DLY	相对模式
从任务调用本函数的时刻算起，
延时OS_TICK变量指定的时间
 	 	 	 	OS_OPT_TIME_MATCH	绝对模式
从上电的时刻算起，
延时OS_TICK变量指示的时间
 	 	 	 	OS_OPT_TIME_PERIODIC	周期模式
从任务调用本函数的时刻算起，每经过一个周期，都会对该人物执行唤醒操作
 	 	 	取值
范围	OS_OPT_TIME_HMSM_STRICT	小时：0~99
分：0~59
秒：0~59
毫秒：0~999
 	 	 	 	OS_OPT_TIME_HMSM_NON_STRICT	小时：0~999
分：0~9999
秒：0~65535
毫秒：0~4294967295
 	 	OS_ERR
指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	输出	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OPT_INVALID	
 	 	 	OS_ERR_SCHED_LOCKED	
 	 	 	OS_ERR_TIME_DLY_ISR	
 	 	 	OS_ERR_TIME_INVALID_HOURS	
 	 	 	OS_ERR_TIME_INVALID_MINUTES	
 	 	 	OS_ERR_TIME_INVALID_SECONDS	
 	 	 	OS_ERR_TIME_INVALID_MILLISECONDS	
 	 	 	OS_ERR_TIME_ZERO_DLY	
 	使用	要使用这个函数需要将os_cfg.h文件中的OS_CFG_TIME_DLY_HMSM_EN置1
使用该函数指定具体的延时时间，精确到：小时/分/秒/毫秒；
OSTimeDlyResume
延时等待恢复	输入	OS_TCB
指针	某个处于延时等待状态的任务的任务控制块
 	 	OS_ERR
指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	输出	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_STATE_INVALID	
 	 	 	OS_ERR_TIME_DLY_RESUME_ISR	
 	 	 	OS_ERR_TIME_NOT_DLY	
 	 	 	OS_ERR_TASK_SUSPENDED	
 	使用	要使用这个函数需要将os_cfg.h文件中的OS_CFG_TIME_DLY_RESUME_EN置1
优先级：任务B>任务A
任务B正处于延时等待中，
任务A调用OSTimeDlyResume函数，且输入的第一个参数是任务B的任务控制块；
任务B取消等待，其优先级更高，所以夺取CPU控制权，任务B进入运行态，任务A进入就绪态；
注意：任务B并不知道它是被其他任务恢复的，它会认为是延时结束而得到恢复的，因此需要谨慎使用该函数
OSTimeGet	输入	OS_ERR指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	输出	OS_TICK变量	当前时钟节拍计数器OSTickCtr的值
 	 	OS_ERR
变量赋值	OS_ERR_NONE	
 	 	 		
 	使用	通过该计数器的值，用户可以跟踪事件，同时，用户可以反复地将任务延时指定的节拍数
OSTimeSet	输入	OS_TICK 变量	设定时钟节拍计数器的目标值
 	 	OS_ERR指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	输出	OS_ERR
变量赋值	OS_ERR_NONE	
 	 	 		
 	使用	允许用户改变当前的时钟节拍器的数值，这个函数一定要谨慎使用！

### 时钟节拍列表
定义	时钟节拍列表就是OS_TICK_SPOKE类型数组 OSCfg_TickWheel[]；定义位置：os_cfg_app.h
系统中只有一个时钟节拍列表；
表项	时钟节拍列表的表项是系统中所有 正在等待延时结束 或 在指定时间内等待某个内核对象 的任务；
时钟节拍列表是一个环形表，所以也称为时钟节拍轮，数组的每个元素称为一根“辐条”；
每一根辐条可以容纳多个表项
辐条是OS_TICK_SPOKE类型的变量，其定义见下表
 	成员	数据类型	说明
 	FirstPtr	OS_TCB指针	该辐条上 排在最前面的 任务 的任务控制块 的地址
 	NbrEntries	OS_OBJ_QTY变量	该辐条上当前的任务的数目
 	NbrEntriesMax	OS_OBJ_QTY变量	该辐条上的任务的最大数目
容量	OS_CFG_TICK_WHEEL_SIZE	OSCfg_TickWheel数组的容量，定义位置：os_cfg_app.h
表示时钟节拍列表中的辐条数目的最大值；
一般设置数组的容量为总任务数目的1/4左右；
注意：OS_CFG_TICK_WHEEL_SIZE的值要为素数；
 	时钟节拍列表的容量	由于一个OSCfg_TickWheel数组元素可以包含多个任务，所以列表的容量为：
OSCfg_TickWheel[0].NbrEntriesMax + OSCfg_TickWheel[1].NbrEntriesMax + ……+ OSCfg_TickWheel[OS_CFG_TICK_WHEEL_SIZE – 1].NbrEntriesMax
 	OSCfg_TickWheelSizeRAM	时钟节拍列表的大小，定义位置：：os_cfg_app.h
表示整个时钟节拍列表占据的存储空间的大小
OSCfg_TickWheelSizeRAM= sizeof (OSCfg_TickWheel)
链接	如：时钟节拍列表中的某个辐条：OSCfg_TickWheel[n] (0<n<OS_CFG_TICK_WHEEL_SIZE)；
该辐条中任务的数目：OSCfg_TickWheel[n].NbrEntries
辐条头任务控制块地址：OSCfg_TickWheel[n]. FirstPtr
第2个任务控制块地址：(OSCfg_TickWheel[n]. FirstPtr)->TickNextPtr
第3个任务控制快地址：((OSCfg_TickWheel[n]. FirstPtr)->TickNextPtr)->TickNextPtr

向时钟节拍列表
插入任务	OS_TickListInsert	输入	OS_TCB
指针	要插入的任务的任务控制块地址
 	 	 	OS_TICK
变量	延时的时间 或 等待超时的时间；
单位：时钟节拍
 	 	 	OS_OPT
变量	OS_OPT_TIME_DLY	相对模式
 	 	 	 	OS_OPT_TIME_PERIODIC	周期模式
 	 	 	 	OS_OPT_TIME_MATCH	绝对模式
 	 	 	OS_ERR
指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	 	输出	OS_ERR
变量赋值	OS_ERR_NONE	
 	 	 	 	OS_ERR_TIME_ZERO_DLY	
 	设置
任务
控制块	设置所插入的任务的任务控制块的TickCtrPrev和TickCtrMatch这两个成员
假设配置任务延时n个时间节拍或等待超时时间为n个时间节拍，
那么在OSTickCtr=X 的时刻插入一个任务时：
TickCtrPrev=X
TickCtrMatch=TickCtrPrev+n
 	插入到
哪根
辐条	Index表示这个任务要插入到的辐条的序号，(0≤Index≤OS_CFG_TICK_WHEEL_SIZE–1)
Index本应该等于任务延时或等待超时的终止时刻的OSTickCtr数值即TickCtrMatch成员的值，
如果超出了辐条的总数，那就回到第一根辐条继续算下去；所以称时钟节拍列表为时钟节拍轮；
所以：Index= TickCtrMatch % OS_CFG_TICK_WHEEL_SIZE  (取余)
 	设置
辐条	已知将任务插入到辐条OSCfg_TickWheel[Index]中，那么
OSCfg_TickWheel[Index]. NbrEntries ++
比较各个任务的延时或超时等待的剩余时间，
OSCfg_TmrWheel[Index]. FirstPtr = 剩余时间最少的软件定时器的地址
 	插入到
辐条的
哪个
位置	在辐条中的任务：
OSCfg_TickWheel[Index]. FirstPtr 存储TickRemain成员值最小的任务的任务控制块的地址
即剩余时间少的任务放在辐条的前面。
从时钟节拍列表
删除任务	OS_TickListRemove	输入	OS_TCB
指针	要删除的目标任务的任务控制块地址
	OS_TickListResetPeak	

### 时钟节拍任务

任务控制块	时钟节拍任务是一个系统任务；它的任务控制块是OSTickTaskTCB，定义位置：os.h
任务堆栈	堆栈数组：OSCfg_TickTaskStk[]，定义位置：os_cfg_app.c
堆栈容量：OS_CFG_TICK_TASK_STK_SIZE，定义位置：os_cfg_app.c
堆栈基地址：OSCfg_TickTaskStkBasePtr=&OSCfg_TickTaskStk[0]，定义位置：os_cfg_app.c
堆栈大小：OSCfg_TickTaskStkSizeRAM=sizeof(OSCfg_TickTaskStk)，定义位置：os_cfg_app.c
增长限位值：OSCfg_TickTaskStkLimit，定义位置：os_cfg_app.c
OS_CFG_TICK_TASK_STK_LIMIT，定义位置：os_cfg_app.c

任务优先级	优先级大小是OS_CFG_TICK_TASK_PRIO，定义位置：os_cfg_app.c
一般会设置比较高的优先级，比最高优先级略低一点
任务函数
OS_TickTask	介入函数
OSTimeTickHook
	任务函数首先会调用这个介入函数允许用户在时钟节拍到来时设置额外的操作
实际使用这个介入函数时，需要用户另外编写一个额外操作函数，将该函数的地址赋给OS_AppTimeTickHookPtr变量，以供OSTimeTickHook()函数调用；
介入函数在时钟节拍函数中最先被调用，这对于一些应用是有利的，如：
1.在介入函数中读取传感器，可以保证采样时刻的均匀，避免其他代码执行时间的变化导致采样时刻的抖动
2.在介入函数中更新PWM寄存器，保证输出脉冲的精度；
 	请求信号量	时钟节拍任务请求一个信号量而进入等待态；
每发生一次时基中断，中断服务程序(时基事件)释放一个信号量，一般时钟节拍任务的优先级很高，所以一般总是由时钟节拍任务获得这个信号量，进入运行态

 	更新节拍计数器	OSTickCtr ++
 	更新
时钟节拍列表
OSTickListUpdate	注：先更新节拍计数器，再更新节拍列表，调用OSTickListUpdate()函数来更新时钟节拍列表
遍历时钟节拍轮的每个辐条。检查一个辐条时，从最前面的任务开始
如果发现一个任务的TickCtrMatch=OSTickCtr，则该任务延时或超时判断结束，这个任务从时间节拍列表剔除，这个任务将进入就绪态；
然后继续检查下面的任务，直到发现一个任务的TickCtrMatch不等于OSTickCtr，那么立刻结束这个对这个辐条的检查，进入下一个辐条的检查。
因为辐条上的任务是按照每个任务的的TickRemain升序排列的，延时最先结束的任务总是放在最前面，如果前面的任务还没结束，那么后面的肯定也没到。
 	设置任务控制块	踢出延时结束或超时判断结束的任务后，剩下的所有任务的任务控制块：
TickRemain成员值减1
 	设置辐条	辐条的FirstPtr和NbrEntries两个成员都可能相应地改动



OS_TickTaskInit	输入	OS_ERR
指针	传递一个空OS_ERR变量的地址，用于存储错误信息
 	输出	OS_ERR
变量
赋值	


定时器
系统定时器
系统定时器	使能定时器功能：将os_cfg.h文件中的OS_CFG_TMR_EN置1；
定时器与时钟节拍有类似的地方；
时钟节拍是基于一个硬件定时器的，一个时基中断对应一个时钟节拍对应执行一次时钟节拍任务
定时器节拍是基于时钟节拍的，多个时钟节拍对应一个定时器节拍对应执行一次定时器任务；
定时器节拍频率由时钟节拍频率分频得到，因此定时器节拍频率小于或等于时钟节拍频率
如：时钟节拍设置位1000Hz，定时器节拍设置为10Hz，那么意味着100个时钟节拍会触发一次定时器任务

系统定时器是为软件定时器服务的；
系统中只有一个系统定时器，但可以有无数个软件定时器(只要RAM空间足够)
但每个软件定时器都来源于系统定时器
系统定时器节拍频率	定时器节拍频率是OSCfg_TmrRate_Hz，定义位置：os_cfg_app.c
取值：10~~1000
单位：Hz
定时计数器	定时计数器是OS_TICK类型的变量OSTmrTickCtr，定义位置：os.h
单位：定时器节拍 =（OSCfg_TmrRate_Hz / OSCfg_TickRate_Hz）* 时钟节拍
系统复位时，时钟计数器设置为0；
在定时器任务中，会递增定时计数器的值，即：每经过一个定时器节拍，计数器加1






软件定时器
时基中断时钟节拍系统定时器软件定时器
软件定时器是递减计数器，计数器减到0时可以触发回调函数的执行。
理论上，uC/OS–III可以创建无数个软件定时器，这是硬件定时器(时钟节拍)无法媲美的。
但但其精度达不到硬件定时器的标准，可以用于定时一些精度要求不是特别严格的事件。

OS_TMR	成员	数据类型	说明
 	Type	OS_OBJ_TYPE变量	该结构类型变量表示的是定时器；
 	NamePtr	CPU_CHAR指针	该定时器的名称，字符串
 	CallbackPtr	OS_TMR_CALLBACK_PTR
变量	回调函数的地址，即回调函数的函数名
NULL表示这个软件定时器计数到0时，不调用回调函数
 	CallbackPtrArg	void指针	传递回调函数的参数
 	NextPtr	OS_TMR指针	在定时器列表中，该定时器的上一个定时器的地址
如果表中只有一个定时器，那么NextPtr=NULL
 	PrevPtr	OS_TMR指针	在定时器列表中，该定时器的下一个定时器的地址
如果表中只有一个定时器，那么NextPtr=NULL
 	Match	OS_TICK
变量	该定时器终止计数的时刻，定时计数器OSTmrTickCtr的值，
单位：定时器节拍
 	Remain	OS_TICK
变量	该定时器正在计数的此刻，计数剩余值
Remain= Match– Dly
单位：定时器节拍
 	Dly	OS_TICK
变量	该定时器开始计数的时刻，定时计数器OSTmrTickCtr的值
单位：定时器节拍
 	Period	OS_TICK
变量	仅在周期定时模式下有效
作为周期定时器第二个以及后面的周期的定时的初始值；
 	Opt	OS_OPT
变量	OS_OPT_TMR_NONE	未选择模式
 	 	 	OS_OPT_TMR_ONE_SHOT	单次定时器
 	 	 	OS_OPT_TMR_PERIODIC	周期定时器
 	 	 	OS_OPT_TMR_CALLBACK	使用OSTmrStop()操作该定时器时
 	 	 	OS_OPT_TMR_CALLBACK_ARG	使用OSTmrStop()操作该定时器时
 	State	CPU_STATE
变量	OS_TMR_STATE_UNUSED	未使用状态，定时器不在定时器列表中
 	 	 	OS_TMR_STATE_STOPPED	停止状态，定时器在定时器列表中，定时器不在计数
 	 	 	OS_TMR_STATE_RUNNING	运行状态，定时器在定时器列表中，定时器正在计数
 	 	 	OS_TMR_STATE_COMPLETED	完成状态，定时器在定时器列表中，定时器计数完毕
回调
函数	回调函数的内容可以由用户自己设置。
注意避免在回调函数中使用阻塞调用（即：使任务进入等待态，如调用函数OSTimeDly()，OS???Pend()等，或者任务可以阻塞或删除定时器任务的函数）
回调函数是从定时器任务的运行环境中调用的，用户可以创建任意数目的定时器(仅受可用RAM空间的限制)
回调函数的代码在文件app.c中编写
回调函数的执行是在定时器任务内完成的，也就是说应用程序本身必须要确定有足够的堆栈空间供定时器来处理这些回调函数。
每个回调函数执行的顺序是根据它们在定时器列表中的位置决定的；
定时器任务的执行时间取决于有多少个定时器计时结束了，以及它们的回调函数执行所需的时间总和。由于回调函数本身是应用程序提供的，所以它们对定时器任务的执行时间有很大的影响。
定时器回调函数不允许等待事件，因为这样会占用定时器任务的时间
调用回调函数时，调度器是上了锁的，所以必须要保证回调函数尽快执行完毕。




OSTmrCreate
创建一个
软件定时器
并将其
插入到
定时器
列表中
	输入	OS_TMR
指针	事先定义好一个OS_TMR结构类型的变量；
调用OSTmrCreate()时，将该变量的地址作为参数传递给函数。
OSTmrCreate()函数实现对某个OS_TMR结构类型变量的初始化
 	 	CPU_CHAR
指针	该定时器的名称，字符串
 	 	OS_TICK
变量	表示定时计数器的初始延迟值；
单位：定时器节拍，
 	 	 	单次
模式	定时器一旦被启动，其计数器从初始延迟值开始倒计数，
直到计到0时调用回调函数；完成一次定时
 	 	 	周期
模式	初始延迟值≠0→第一个周期，计数器从初始延迟值开始倒计数；之后的每个周期，开始时计数器重置为重复周期值，从重复周期值开始倒计数；
初始延迟值=0→周期定时器每一个周期(包括第一个)都是从重复周期值开始倒计数；
 	 	OS_TICK
变量	重复周期，仅在周期模式下有效
初始延迟值=0：周期定时器每次定时都是从重复周期值开始倒计数；
初始延迟值≠0：周期定时器除第一个周期以外，其他的周期都从重复周期值开始倒计数
 	 	OS_OPT
变量	OS_OPT_TMR_ONE_SHOT	一次定时完成之后，计数器保持为0，计时停止；
直到再次启动该定时器；
 	 	 	OS_OPT_TMR_PERIODIC	一次定时完成之后，定时计数器自动重置；
自动开始下一轮定时，一直循环下去；
 	 	OS_TMR_CALLBACK_PTR变量	回调函数的函数地址，即回调函数的函数名
 	 	void指针	回调函数的输入参数
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_ILLEGAL_CREATE_RUN_TIME	
 	 	 	OS_ERR_OBJ_CREATED	
 	 	 	OS_ERR_OBJ_PTR_NULL	
 	 	 	OS_ERR_OBJ_TYPE	
 	 	 	OS_ERR_OPT_INVALID	
 	 	 	OS_ERR_TMR_INVALID	
 	 	 	OS_ERR_TMR_INVALID_DLY	
 	 	 	OS_ERR_TMR_INVALID_PERIOD	
 	 	 	OS_ERR_TMR_ISR	
 	使用	该函数对定时器做状态转换：未使用停止
 	 	设置
软件
定时器	设置所插入的软件定时器的Dly和Match这两个成员
假设配置单次定时器定时n个定时器节拍，即给本函数传递的第3个参数-OS_TICK类型变量=n
那么在OSTmrCtr=X 的时刻插入一个任务时：软件定时器的  Dly=n  ， Match=X+n
 	 	插入到
哪根
辐条	Index表示这个任务要插入到的辐条的序号，(0≤Index≤OS_CFG_Tmr_WHEEL_SIZE–1)
Index本应该等于软件定时器定时终止时刻的OSTmrCtr数值即Match成员的值，
如果超出了辐条的总数，那就回到第一根辐条继续算下去；
所以：Index = Match % OS_CFG_Tmr_WHEEL_SIZE  (取余)
 	 	设置
辐条	已知将任务插入到辐条OSCfg_TmrWheel[Index]中，那么OSCfg_TmrWheel[Index]. NbrEntries ++
比较各个软件定时器的剩余时间，OSCfg_TmrWheel[Index]. FirstPtr =剩余时间最少的软件定时器的地址
 	 	插入到
辐条的
哪个位置	在辐条中的任务：
OSCfg_TmrWheel[Index]. FirstPtr 存储Remain成员值最小的任务的任务控制块的地址
即剩余时间最少的软件定时器放在辐条的前面。
OSTmrDel	输入	OS_TMR指针	要删除的目标定时器的地址
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	CPU_BOOLEAN
变量	DEF_TURE	函数执行完毕后查看定时器状态，
如果定时器处于未使用状态就返回DEF_TURE，
如果不是，就返回DEF_FALSE
所以注意：删除并不是真的删除，只是进入未使用状态；
 	 	 	DEF_FALSE	 
 	 	OS_ERR
变量赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OBJ_TYPE	
 	 	 	OS_ERR_TMR_INVALID	
 	 	 	OS_ERR_TMR_ISR	
 	 	 	OS_ERR_TMR_INACTIVE	
 	 	 	OS_ERR_TMR_INVALID_STATE	
 	使用	停止未使用
运行未使用

定时器服务
OSTmrStart	输入	OS_TMR指针	操作的目标软件定时器的地址
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	CPU_BOOLEAN
变量	DEF_TURE	函数执行完毕后查看定时器状态，如果定时器处于运行状态就返回DEF_TURE，如果不是，就返回DEF_FALSE
 	 	 	DEF_FALSE	 
 	 	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OBJ_TYPE	if 'p_tmr' is not pointing to a timer
 	 	 	OS_ERR_TMR_INVALID	
 	 	 	OS_ERR_TMR_INACTIVE	if the timer was not created
 	 	 	OS_ERR_TMR_INVALID_STATE	the timer is in an invalid state
 	 	 	OS_ERR_TMR_ISR	if the call was made from an ISR
 	使用	单次定时器	定时器重置为初始延迟值开始计时
 	 	周期定时器	无初始延迟	计数器重置为重复周期值然后开始计时
 	 	 	有初始延迟	计数器重置为初始延迟值然后开始计时
第二次及以后的周期重置为重复周期值
 	 	停止状态运行状态：开始计时
运行状态运行状态：重新开始计时
OSTmrStop	输入	OS_TMR指针	操作的目标软件定时器的地址
 	 	OS_OPT
变量	OS_OPT_TMR_NONE	只是单纯停止该定时器
 	 	 	OS_OPT_TMR_CALLBACK	停止定时器，并执行回调函数，传递给回调函数的参数是该定时器的CallbackPtrArg成员
 	 	 	OS_OPT_TMR_CALLBACK_ARG	停止定时器，并执行回调函数，传递给回调函数的参数是本函数的void指针输入参数
 	 	void指针	仅当使用OS_OPT_TMR_CALLBACK_ARG模式时有效；作为回调函数的输入参数
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	CPU_BOOLEAN
变量	DEF_TURE	函数执行完毕后查看定时器状态，如果定时器处于停止状态就返回DEF_TURE，如果不是，就返回DEF_FALSE
 	 	 	DEF_FALSE	 
 	 	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OBJ_TYPE	if 'p_tmr' is not pointing to a timer
 	 	 	OS_ERR_OPT_INVALID	if you specified an invalid option for 'opt'
 	 	 	OS_ERR_TMR_INACTIVE	if the timer was not created
 	 	 	OS_ERR_TMR_INVALID	'p_tmr' is a NULL pointer
 	 	 	OS_ERR_TMR_INVALID_STATE	the timer is in an invalid state
 	 	 	OS_ERR_TMR_ISR	if the function was called from an ISR
 	 	 	OS_ERR_TMR_NO_CALLBACK	if the timer does not have a callback function defined
 	 	 	OS_ERR_TMR_STOPPED	在使用这个函数前，该定时器已经处于停止状态
OSTmrRemainGet	输入	OS_TMR指针	要查看的目标软件定时器的地址
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_TICK	定时器处于
计数状态	返回该定时器的剩余时间，单位：定时器节拍，
如：OS_CFG_Tmr_RATE_HZ=10Hz时，返回50对应剩余时间是5s
 	 	 	定时器处于
停止状态	单次定时器	返回该定时器的初始延迟值
 	 	 	 	有初始延迟的周期定时器	返回该定时器的初始延迟值
 	 	 	 	无初始延迟的周期定时器	返回该定时器的重复周期值
 	 	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OBJ_TYPE	if 'p_tmr' is not pointing to a timer
 	 	 	OS_ERR_OPT_INVALID	'p_tmr' is a NULL pointer
 	 	 	OS_ERR_TMR_ISR	if the function was called from an ISR
 	 	 	OS_ERR_TMR_INACTIVE	'p_tmr' points to a timer that is not active
 	 	 	OS_ERR_TMR_INVALID_STATE	the timer is in an invalid state
OSTmrStateGet	输入	OS_TMR指针	要查看的目标定时器的地址
 	 	OS_ERR指针	传递一个空白的OS_ERR变量，用于存储错误信息
 	输出	OS_STATE	OS_TMR_STATE_UNUSED	未使用
 	 	 	OS_TMR_STATE_STOPPED	停止
 	 	 	OS_TMR_STATE_RUNNING	运行
 	 	 	OS_TMR_STATE_COMPLETED	完成
 	 	OS_ERR
变量
赋值	OS_ERR_NONE	
 	 	 	OS_ERR_OBJ_TYPE	if 'p_tmr' is not pointing to a timer
 	 	 	OS_ERR_OPT_INVALID	'p_tmr' is a NULL pointer
 	 	 	OS_ERR_TMR_INVALID_STATE	the timer is in an invalid state
 	 	 	OS_ERR_TMR_ISR	if the call was made from an ISR
OS_TmrLink	输入	OS_TMR
指针	
 	 	OS_OPT
指针	
 	输出	无
 	使用	
OS_TmrUnlink	输入	OS_TMR
指针	
 	输出	无
 	使用	
OS_TmrLock	输入	void
指针	
 	输出	无
 	使用	
OS_TmrUnlock	输入	void
指针	
 	输出	无
 	使用	


定时器列表
定义	定时器列表就是OS_TICK_SPOKE类型数组 OSCfg_TmrWheel[OS_CFG_TMR_WHEEL_SIZE]，定义位置：os_cfg_app.h
系统中只有一个定时器列表
组成定时器列表(数组)  的元素是OS_TICK_SPOKE 结构类型的变量
表项	定时器列表和时钟节拍列表一样，是一个环形表，数组的每个元素称为一根“辐条”；
每一根辐条可以容纳多个表项
但不同于时钟节拍列表的表项是任务控制块，定时器列表的表项是软件定时器；
辐条是OS_TICK_SPOKE类型的变量，其定义见下表
 	成员	类型	说明
 	FirstPtr	OS_TCB指针	该辐条上 排在最前面的 任务 的任务控制块 的地址
 	NbrEntries	OS_OBJ_QTY变量	该辐条上当前的任务的数目
 	NbrEntriesMax	OS_OBJ_QTY变量	该辐条上的任务的最大数目
容量	OS_CFG_TMR_WHEEL_SIZE	OSCfg_TmrWheel数组的容量，定义位置：os_cfg_app.h
表示定时器列表中的辐条数目的最大值；
一般设置数组的容量为总任务数目的1/4左右；
注意：建议将OS_CFG_TMR_WHEEL_SIZE的值设置为素数；
 	定时器列表的容量	由于一个OSCfg_TmrWheel数组元素可以包含多个任务，所以列表的容量为：
OSCfg_TmrWheel[0].NbrEntriesMax + OSCfg_TmrWheel[1].NbrEntriesMax + ……+ OSCfg_TmrWheel[OS_CFG_TMR_WHEEL_SIZE – 1].NbrEntriesMax
 	OSCfg_TmrWheelSizeRAM	定时器列表的大小，定义位置：os_cfg_app.h
表示整个定时器列表占据的存储空间的大小
OSCfg_TmrWheelSizeRAM= sizeof (OSCfg_TmrWheel)
链接	如：时钟节拍列表中的某个辐条：OSCfg_TmrWheel[n] (0<n<OS_CFG_TMR_WHEEL_SIZE)；
该辐条中任务的数目：OSCfg_TmrWheel[n].NbrEntries
辐条头任务控制块地址：OSCfg_TmrWheel[n]. FirstPtr
第2个任务控制块地址：(OSCfg_TmrWheel[n]. FirstPtr)->TmrNextPtr
第3个任务控制快地址：((OSCfg_TmrWheel[n]. FirstPtr)->TmrNextPtr)->TmrNextPtr



OS_TmrDbgListAdd	输入	OS_TMR指针	
 	使用	#if OS_CFG_DBG_EN > 0u

 


OS_TmrDbgListRemove	输入	OS_TMR
指针	
 	使用	#if OS_CFG_DBG_EN > 0u


OS_TmrClr	输入	OS_TMR指针	
 	使用	
OS_TmrInit	输入	OS_ERR
指针	
 	输出	OS_ERR
变量
赋值	
 	使用	
OS_TmrResetPeak	输入	无
 	输出	无
 	使用	


定时器任务
任务控制块	定时器任务是一个系统任务；它的任务控制块是OSTmrTaskTCB，定义位置：os.h
任务堆栈	堆栈数组：OSCfg_TmrTaskStk[]，定义位置：os_cfg_app.c
堆栈容量：OSCfg_TickTaskStkSize，定义位置：os_cfg_app.c
堆栈基地址：OSCfg_TmrTaskStkBasePtr=&OSCfg_TmrTaskStk[0]，定义位置：os_cfg_app.c
堆栈大小：OSCfg_TmrTaskStkSizeRAM=sizeof(OSCfg_TmrTaskStk)，定义位置：os_cfg_app.c
增长限位值：OSCfg_TmrTaskStkLimit，定义位置：os_cfg_app.c
OS_CFG_TICK_TASK_STK_LIMIT，定义位置：os_cfg_app.c
任务优先级	优先级大小是OSCfg_TickTaskPrio，定义位置：os_cfg_app.c
任务函数
OS_TmrTask		
 	请求
信号量	时钟节拍任务请求一个信号量而进入等待态；
每发生一次时基中断，中断服务程序(时基事件)释放一个信号量，一般时钟节拍任务的优先级很高，所以一般总是由时钟节拍任务获得这个信号量，进入运行态

 	更新定时
计数器	OSTickCtr ++
 	更新
定时列表	注：先更新节拍计数器，再更新定时器列表
遍历定时器列表的每个辐条。检查一个辐条时，从最前面的任务开始
如果发现一个软件定时器的Match=OSTmrCtr，则该软件定时器定时结束，这个软件定时器从定时器列表剔除，OS_TmrTask()会调用这个软件定时器的回调函数；这个软件定时将进入完成状态(单次)，或重新计时(周期)

然后继续检查下面的软件定时器，直到发现一个软件定时器的Match不等于OSTmrCtr，
那么立刻结束这个对这个辐条的检查，进入下一个辐条的检查。
因为辐条上的软件定时器是按照每个软件定时器的的Remain升序排列的，延时最先结束的软件定时器总是放在最前面，如果前面的软件定时器还没结束，那么后面的肯定也没到。
 	设置
软件
定时器	踢出延时结束或超时判断结束的软件定时器后，剩下的所有任务的任务控制块：
Remain成员值减1
 	设置
辐条	辐条的FirstPtr和NbrEntries两个成员都可能相应地改动







# 存储管理

## 存储管理

### 分配存储空间
- 静态分配
	
- 动态分配
	


## 存储分区

### 存储分区
使能	OS_CFG_MEM_EN置1，位置：os_cfg.h
存储分区	在C语言中，常使用malloc()和free()两个函数来动态地分配和释放存储空间。
但在嵌入式系统中一般不会使用它们，多次使用这两个函数会吧原来很大的一块连续存储区域逐渐分割成许多非常小而且彼此不相邻的存储区域—存储碎片。
uc/OS系统中，为了尽量减少内存在不断分配和释放过程造成的内存碎片，避免过多的浪费内存。
可以将连续的存储空间进行分区管理，每个分区包含整数个大小相同的存储块，由系统管理。
内存分区就是一次性开辟一大块连续内存，然后将内存分区平均分成若干个内存块，需要使用内存时就申请一个内存块，用完了再释放回内存分区，这样就实现内存块的循环使用。

一个存储分区就是一个OS_MEM结构类型变量
存储分区	
OS_MEM	成员	数据类型	说明
 	Type	OS_OBJ_TYPE变量	Type = OS_OBJ_TYPE_MEM，表示这个结构类型变量表示一个存储分区
 	NamePtr	CPU_CHAR指针	该存储分区的名称，字符串
 	BlkSize	OS_MEM_SIZE变量	每个存储分区的容量不得小于保存一个指针变量所需的空间。
每个分区中需要
 	NbrMax	OS_MEM_QTY变量	
 	NbrFree	OS_MEM_QTY变量	
 	FreeListPtr	void指针	存储分区中第一个存储块的地址
 	AddrPtr	void指针	
 	DbgPrevPtr	OS_MEM指针	
 	DbgNextPtr	OS_MEM指针	
 	MemID	CPU_INT32U变量	

OSMemCreate	输入	OS_MEM指针	输入一个存储分区的地址
 	 	CPU_CHAR指针	存储分区的名称，字符串
 	 	void指针	为存储块预留的存储区域的基地址
 	 	OS_MEM_QTY变量	该存储分区中存储块的数目
 	 	OS_MEM_SIZE变量	该存储分区中每个存储块的大小。
 	 	OS_ERR指针	返回错误代码
 	输出	OS_ERR
	
 	使用	OSMemCreate仅供任务级程序使用，不能再ISR中使用
 	 	调用OS_MemInit函数，OS_CFG_DBG_EN置1
初始化该存储分区的各个成员
 	 	调用OS_MemDbgListAdd函数，OS_CFG_DBG_EN置1
将该存储
 	 	





### 获取存储块
OSMemGet	输入	OS_MEM
指针	使用OSMemGet()时，会将一个已经创建的存储分区的地址作为这个函数的第一个参数传递给它
 	 	OS_ERR
指针	返回错误代码
 	输出	无	
 	使用	从分区中获得存储块
归还存储块
OSMemPut	输入	OS_MEM
指针	使用OSMemPut()时，会将一个已经创建的存储分区的地址作为这个函数的第一个参数传递给它
 	 	void
指针	归还的存储块的地址
 	 	OS_ERR
指针	返回错误代码
 	输出	无	
 	使用	将存储块归还到分区中


### 使用存储分区
本例中，任务A读取模拟输入的值，并检查其是否超过阈值，如果超过则给任务B发送一个消息，该消息包含出错的通道，错误代码，错误严重程度以及其他信息。
任务A处于运行态	任务读取模拟输入，该任务检查该模拟输入，发现有一路模拟输入超过有效范围，需要向任务B发送错误信息。
	任务从存储分区中获得一个存储块以便存放错误相关信息
	任务将出错的通道、错误代码、错粗严重程度、可能的解决方案以及其它信息写入存储块。
因为添加时间戳操作是μC/OS的内嵌特性，所以没有必要在消息中加时间戳，即使不加接受任务也会知道消息发出的时刻
	在消息组装完成后，会被发送给任务B。
当然，接收消息的任务需要知道消息的组装结构。按照惯例，发送消息后，模拟输入读取任务就不允许再读/写存储块了，因为该存储块已经被发出去等待处理。
	通常，任务B处于等待消息队列的状态，消息队列处于空闲状态。
当有消息发送给消息队列，该消息立即传送给任务B，任务B进入运行态
	接收到消息后，任务B读取消息的内容，并进行必要的操作。一旦发送，发送方就不能再对消息进行任何操作。
	当任务B完成消息处理后，会将该存储块归还存储分区。
因此，发送方和接收方需要知道存储分区的基本信息，或者发送方将存储分区的地址最为消息的一部分发送给任务B，这样任务B才会知道将存储块归还到何处。
	当分区中没有空闲的存储块的时候，就必须让任务等待空闲的存储块。
但μC/OS不直接支持等待存储块的功能，但是通过给信号量计数器加1的方法可以间接实现这个功能
信号器初期值应设置为分区中存储块的数目。
获得存储块时，先调用OSSemPend()函数，再调用OSMemGet()函数
获得存储块时，先调用OSMemPut()函数，再调用OSSemPost()函数


### 存储块传递数据
假设一个设备以某种协议向串口发送字节流数据包。数据包的第一个字节和最后一个字节都是唯一的，可以用来区分数据包的开始和结束。

产生中断，进入中断服务程序	一旦收到字符串，串口产生中断
中单服务程序读取串口收到的字节，并检查是否是数据包的开头。
如果是，就从存储分区管理器获得一块存储块作为缓存区。收到的字节被放入缓存区。

把缓存区地址放入消息队列	当收到数据包结尾的标识符时，便把缓存区的地址发布到消息队列，以便任务可以处理收到的数据包
	如果发布的消息使得串口处理任务变为最高优先级的任务，那么在中断服务程序结束时，程序便切换到这个任务，而不返回到原来被中断的哪个任务。

串口处理任务	从消息队列中取出数据包（确切的说是取出指向数据包的指针）。
注意：OSQPend()返回的还有数据包的长度（以字节为单位）和消息发布时间的时间戳。
	串口处理任务处理完数据包，通过调用OSMemPut()释放存储块，将其返回给存储分区管理器。
	
	

## 任务存储

OS_TLS_GetID	输入	OS_ERR
指针	
 	输出	OS_TLS_ID	
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_GetValue	输入	OS_TCB
指针	
 	 	OS_TLS_ID
变量	
 	 	OS_ERR
指针	
 	输出	OS_TLS	
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_Init	输入	OS_ERR
指针	
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_SetValue	输入	OS_TCB
指针	
 	 	OS_TLS_ID
变量	
 	 	OS_TLS
变量	
 	 	OS_ERR
指针	
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_SetDestruct	输入	OS_TLS_ID
变量	
 	 	OS_TLS_DESTRUCT_PTR
变量	
 	 	OS_ERR
指针	
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_TaskCreate	输入	OS_TCB
指针	
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_TaskDel	输入	OS_TCB
指针	
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
OS_TLS_TaskSw	输入	无
 	输出	无
 	使用	#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)



# 中断

## 临界段代码

### 中断堆栈
	对于中断，顾名思义是系统在正常运行（执行主程序）的时候，突然发生一个事件，系统停止运行而去处理这个突发事件，处理完了，再回过来继续执行原来的主程序。
所以需要在执行前保存好当前的状态，以备处理完毕后可以完全恢复到原来的状态。

CPU寄存器状态保存在中断堆栈中，如果CPU没有专门的中断堆栈，那么需要做一个软件堆栈指针。（详见中断堆栈）
需要了解如何将CPU寄存器保存到中断堆栈中？将那些寄存器保存到堆栈？如果CPU还配置了浮点数处理单元（FPU），那么还得将FPU的寄存器也保存起来。

中断栈存储的内容
	
中断栈的大小
	CPU确认中断后，将其部分或全部寄存器入栈保存，并跳转执行中断服务程序。
中断控制器负责接收所有的中断请求信号。




### 中断服务程序
中断
控制器	如果在中断关闭的时候，又有其它中断发生，那么它们会进入中断队列。一旦中断被开启，那么中断控制器就会选择优先级最高的中断，系统进入它的中断服务程序。
参数配置	优先级
	中断优先级在板级支持文件中设置
数值越低，优先级越高
任一个中断优先级都高于 所有的任务的优先级

优先级最高的几个优先级固定且唯一分配给了几个很重要的异常。
这几个中断服务 内核是不参与的，一直处于开启的状态，用户不用管它们

中断控制器允许为每个中断请求设置优先级，可以记录哪些中断还未处理，并将当前最高优先级的中断请求的服务程序的地址（也称为中断向量的地址）直接传递给CPU
 	发布方式	配置文件os.cfg.h中的宏定义：   
#define OS_CFG_ISR_POST_DEFERRED_EN     
定义为0表示直接发布
定义为1表示延迟发布
实际编写代码的时候，用户只需要设定 OS_CFG_ISR_POST_DEFERRED_EN  的值，系统会自动进行直接发布或延迟发布

 		配置文件cpu.cfg.h中的宏定义：
#define  CPU_CFG_INT_DIS_MEAS_EN
使能该定义→#if 1

大多数处理器都支持每个中断源对应一个中断服务程序，发生中断请求时处理器根据预设的中断向量表，直接跳转到对应的中断服务程序（中断服务函数）。
系统中，把所有中断服务函数的定义统一放在stm32fxxx_it.c 文件中，便于查看和管理
中断服务函数的函数名是固定的，可以在启动文件中查询。
中断服务程序是临界段代码，用 开/关中断的方式保护。
关闭中断	屏蔽所有可屏蔽的中断。
这里关闭所有中断，并不是一个一个地关闭，而是关闭一个总开关。所以此处虽然是已经关闭所有中断，但中断状态还是保持不变的。
所以此处虽然是已经关闭所有中断，但中断状态还是保持不变的。
某些CPU在进入中断后会自动关闭所有中断，另一些CPU则需要调用特定的指令来关中断。
如果CPU支持多个中断优先级，那么关闭中断这一步的处理会复杂一些。
保存中断状态	因为中断服务程序执行完毕后，还要恢复原来的恢复状态，所以要把当前的中断状态保存起来。
实际上是将CPU中存储中断标志的寄存器的值保存到中断堆栈中。
某些CPU会自动完成保存操作，而其他的CPU则需要用户自己进行操作。
调用OSIntEnter()	递增OSIntNestingCtr
OSIntNestingCtr用于记录当前中断嵌套层数
判断OSIntNestingCtr	如果OSIntNestingCtr=1，表明当前处理的中断是一级嵌套
那么把被中断的任务的任务堆栈的指针保存到一个OS_TCB结构类型的变量中。
全局指针OSTCBCurPtr也相应地指向被中断的任务的任务控制块
清除中断标志	中断服务程序执行完毕后，要清除该中断的标志，避免重复执行
执行一些简短的操作	如：发生串口接收中断时，存储串口接收的数据
发布内核对象给中断处理任务	一个事件对应一个中断服务程序对应一个中断处理任务
因为要求中断服务程序尽可能简短，所以一般不会把 处理这个事件或异常的程序 放在这个事件对应的中断服务程序中，而是放在另一个任务中，我称这个任务为中断处理任务。而中断服务程序只起到一个中转和媒介的作用。这样做就大大缩短了中断服务程序，因为系统为保证运行的流畅性，不希望过多的处于中断服务程序中。
使用中断服务函数发布信号量、消息或事件标志组等内核对象来标志中断的发生，等退出中断后由对应的中断处理任务详细处理中断。
ISR常常只调用与Post相关的这一类函数：
OSFlagPost() ，OSQPost() ，OSSemPost() ，OSTaskQPost() ，OSTaskSemPost() 
唯一一个不允许ISR调用的Post函数是MutexPost()
中断处理任务被创建时进进入了等待态。
当对应的中断发生后，进入中断服务程序，中断服务程序会发布中断处理任务所请求的内核对象。
也存在无需内核对象参与的中断服务程序，那么这一步就省略了。
调用OSIntExit()	递减OSIntNestingCtr
OSIntNestingCtr用于记录当前中断嵌套层数
判断OSIntNestingCtr	如果OSIntNestingCtr=0，表明当前处理中断是最外面的一层，接下来即将退出中断。
接下来就要进行任务调度和任务切换，然后进入任务级代码了。

### 中断处理任务

直接发布	OS_CFG_ISR_POST_DEFERRED_EN =0
中断处理任务是临界段代码，需要保护。
直接发布采用 关闭/打开中断 的方法保护中断处理任务
 	执行一个任务的时候，外设产生中断请求，执行对应的中断服务程序
中断服务程序向中断处理任务释放信号量或发布消息
使对应中断处理任务进入就绪态；一般中断处理任务的优先级较高，那么中断处理任务会马上进入运行态，执行处理中断的代码。
正处于等待态的中断服务程序获得了，中断队列任务发布的内核对象；中断服务程序进入就绪态，如果优先级最高，那就进入运行态，处理中断。
中断处理任务完成后，系统会挂起这个中断处理任务，直到这个外设中断请求再次发生。
系统回到原来那个被中断的任务。
被中断的任务从被中断的地方开始继续运行。


CPU_SR_ALLOC()	创建一个变量 cpu_sr，用于当前存储中断状态

while (DEF_TRUE) {	进入无限循环体
一般中断处理任务都配置配无限循环任务
	
发布内核对象请求	在循环体中，任务发布内核对象请求，然后进入等待态，这个任务被挂起，系统正常运行
一旦发生相应的中断，中断处理任务就会进入运行态处理中断；
处理完毕后任务并不会中止，而是回到循环体的开始处，再次发布内核对象请求，进入等待态，等待中断再次发生

OS_CRITICAL_ENTER()	CPU_CRITICAL_ENTER()	CPU_INT_DIS()	储存CPU的中断标志位至 cpu_sr
 	 	CPU_IntDisMeasStart()	屏蔽所有可屏蔽的中断

中断处理任务主体	由于中断都被屏蔽了，所以在执行临界段代码的时候即使有中断发生，临界段代码继续执行直至完毕。

OS_CRITICAL_EXIT()	CPU_CRITICAL_EXIT()	CPU_IntDisMeasStop()	
 	 	CPU_INT_EN()	恢复之前的中断状态


CPU相关文件提供了开/关中断的函数。见文件cpu.h
不同的CPU会有各自对应的一个cpu.h 文件。相应的也会有各自开/关中断的方法，将各自的方法写入到上述的几个宏中，也就是说总体的代码结构是一样的。
带有CPU前缀的宏，说明是和CPU有关，和系统无关，不同的CPU会使用不同的方法关中断和开中断
CPU_CRITICAL_ENTER()和CPU__CRITICAL_EXIT()这两个宏总是成对调用的





延迟发布
	OS_CFG_ISR_POST_DEFERRED_EN =1
中断处理任务是临界段代码，需要保护。
延迟发布采用 锁定/解锁调度器 的方法保护中断处理任务的主体
 	执行一个任务的时候，外设产生中断请求，执行对应的中断服务程序
中断服务程序向中断处理任务释放信号量或发布消息，虽然在中断服务程序中还是同样的调用了OS???Pend()函数来请求内核对象，但因为正处于延迟模式下，所以系统不会直接执行相关功能操作，而是把请求放到“中断队列”记录起来；同时中断队列处理任务进入就绪态。
中断队列处理任务是一个内部任务，具有最高的优先级，所以系统不会返回到被中断的那个任务，而是切换到中断队列处理任务。中断队列处理任务从中断队列中调用其存储的发布请求，并执行相应的发布操作。然后将自身挂起。
所以正处于等待态的中断服务程序获得了，中断队列任务发布的内核对象；中断服务程序进入就绪态，如果优先级最高，那就进入运行态，处理中断。
中断处理任务完成后，系统会挂起这个中断处理任务，直到这个外设中断请求再次发生。
系统回到原来那个被中断的任务。
被中断的任务从被中断的地方开始继续运行。
相比于直接发布，延迟发布 是使用中断队列处理任务来发布（释放）内核对象，而不是由中断服务函数来发布。
 	


CPU_SR_ALLOC()	创建一个变量 cpu_sr，用于当前存储中断状态
while (DEF_TRUE) {	进入无限循环体
一般中断处理任务都配置配无限循环任务
发布内核对象请求	在循环体中，任务发布内核对象请求，然后进入等待态，这个任务被挂起，系统正常运行
一旦发生相应的中断，中断处理任务就会进入运行态处理中断；
处理完毕后任务并不会中止，而是回到循环体的开始处，再次发布内核对象请求，进入等待态，等待中断再次发生
OS_CRITICAL_ENTER()	1.CPU_CRITICAL_ENTER()	CPU_INT_DIS()	储存CPU的中断标志位至 cpu_sr
 	 	CPU_IntDisMeasStart()	屏蔽所有可屏蔽的中断
 	2.OSSchedLockNestingCtr++	每次调用OS_CRITICAL_ENTER()，OSSchedLockNestingCtr加1
   	3. 判断OSSchedLockNestingCtr                   	如果OSSchedLockNestingCtr大于0
       调用OS_SCHED_LOCK_TIME_MEAS_START()，锁定调度器
       此时不可以使用任务调度，即不可以进行任务切换
            	4. CPU_CRITICAL_EXIT()	CPU_IntDisMeasStop()	
       	 	 	CPU_INT_EN()	恢复之前的中断状态
       	 	OS_CRITICAL_ENTER()同时调用了CPU_CRITICAL_ENTER()和CPU_CRITICAL_EXIT()，这两个宏相互抵消，不产生任何效应，作用是保护  第2和第3部分的代码
       所以不同于OS_CFG_ISR_POST_DEFERRED_EN =0时的情况，当OS_CFG_ISR_POST_DEFERRED_EN =1时
       调用OS_CRITICAL_ENTER()不会关闭中断，即它不是使用“开/关中断”的方法 来保护临界段代码，而是使用“调度器上锁/解锁”的方法

第2和第3部分的代码是OS_CRITICAL_ENTER()的主体
中断处理任务主体	前面已经讲过，在执行临界段代码的时候，可以正常被中断打断。
我们已经知道，一般中断的作用是发布某个内核对象来使某个处于等待态的任务进入就绪态，进而进入运行态 执行。
但是因为前面调用了宏OS_CRITICAL_ENTER()，所以OSSchedLockNestingCtr至少等于1.
所以此时调度器是锁定状态，不能进行任务调度，因为中断而从等待态进入就绪态的任务，也就只能停留在就绪态，无法进入任务态。

所以可以说临界段代码还是受到了保护。这就是“调度器上锁/解锁”保护临界段代码的方法

OS_CRITICAL_EXIT()	1.CPU_CRITICAL_ENTER()	CPU_INT_DIS()	储存CPU的中断标志位至 cpu_sr
 	 	CPU_IntDisMeasStart()	屏蔽所有可屏蔽的中断
   	2. OSSchedLockNestingCtr––	每次调用OS_CRITICAL_EXIT()，OSSchedLockNestingCtr减1
            	3. 判断OSSchedLockNestingCtr
        	如果OSSchedLockNestingCtr等于0
       调用S_SCHED_LOCK_TIME_MEAS_STOP()，解锁调度器
       此时可以可以进行任务调度和任务切换。
       再调用CPU_CRITICL_EXIT()，它与上面的CPU_CRITICAL_ENTER()相互抵消。
       即退出了临界段代码的保护的状态。系统恢复正常状态。

如果OSSchedLockNestingCtr不等于0
为什么会出现这种情况？显然是因为OSSchedLockNestingCtr是一个大于1的数。
这其实是由中断嵌套产生的
因为中断服务程序是临界段代码
OS_CFG_ISR_POST_DEFERRED_EN =1时，
保护中断服务程序，那么在中断服务函数代码前面需要调用
OS_CRITICAL_ENTER()，那么OSSchedLockNestingCtr递增，
在执行中断服务程序的过程中，可能又会出现中断，从而进入另一个中断服务函数，那么还得使用OS_CRITICAL_ENTER()，
那么OSSchedLockNestingCtr再加1。
每次退出一个中断服务程序，OSSchedLockNestingCt会减1。
可以说OSSchedLockNestingCt记录了当前中断嵌套的层数
如果OSSchedLockNestingCt还没有减到0，说明此事任然处于某个中断服务程序中，此时还不可以解锁调度器
直到OSSchedLockNestingCtr等于0


## 中断服务管理任务

OSCfg_IntQTaskStkBasePtr;
OSCfg_IntQTaskStkLimit;
OSCfg_IntQTaskStkSize;
OSCfg_IntQTaskStkSizeRAM;
OSCfg_IntQTaskStk[];

OS_IntQTaskInit	输入	OS_ERR
指针	
 	输出		
 	使用	#if OS_CFG_ISR_POST_DEFERRED_EN > 0u

OS_IntQPost	输入	OS_OBJ_TYPE
变量	
 		void
指针	
 		void
指针	
 		OS_MSG_SIZE
变量	
 		OS_FLAGS
变量	
 		OS_OPT
变量	
 		CPU_TS
变量	
 		OS_ERR
指针	
 	输出		
 	使用	#if OS_CFG_ISR_POST_DEFERRED_EN > 0u

OS_IntQRePost	输入	无	
 	输出		
 	使用	#if OS_CFG_ISR_POST_DEFERRED_EN > 0u

OS_IntQTask	输入	void 
指针	
 	输出		
 	使用	#if OS_CFG_ISR_POST_DEFERRED_EN > 0u





## 时间计算

中断关闭时间	中断处理任务是临界段代码，我们提供了两种方法来保护它们：开/关中断  和  上锁/解锁调度器
不论是直接发布还是延迟发布，它们之前的中断服务程序也是临界段代码，我们只提供一种发发来保护：
开/关中断

在关闭中断的这一期间，发生的中断都无法及时得到处理，而是进入中断队列，要等到重新开启中断后，中断才能得到处理，因此我们不希望程序中过多地关闭中断，如果关闭了中断，也不希望关太长的时间。

如果使用 上锁/解锁调度器 的方法保护中断处理任务（延迟发布），那么这个中断的中断服务程序不需要发布内核对象，只需要访问中断队列，把这个中断放入中断队列，这个步骤所需的时间很短，相对于直接发布，减少了中断关闭的时间。

从中断关闭开始到中断重新被打开，这段时间成为中断关闭时间。
程序中肯定不止一次关闭和开启中断，中断关闭时间各不相同，把时间花的最多的一次中断关闭时间称为最大中断关闭时间。

最大中断关闭时间是实时多任务内核的一个重要的指标

μC/OS–III中，令CPU_CFG_INT_DIS_MEAS_EN=1  就可以使能测量中断关闭时间的功能
使用该功能会更新两个变量：
总的中断关闭时间和单个任务的中断关闭时间。
通过使用这个功能可以查询每个任务的中断关闭时间，然后对系统进行优化。
发生任务切换时，其任务控制块内保存的中断关闭时间就会更新

延迟发布时中断关闭时间相关计算：
μC/OS–III中，令CPU_CFG_SCHED_LOCK_TIME_MEAS_EN=1  就可以使能测量调度锁定时间的功能
使用该功能会更新两个变量：
总的调度锁定时间和单个任务的调度锁定时间。
通过使用这个功能可以查询每个任务的调度锁定时间，然后对系统进行优化。
发生任务切换时，其任务控制块内保存的调度锁定时间就会更新

中断关闭时间和调度锁定时间的单位与系统时间戳CPU_TS的单位一致。如果产生时间戳的频率是1MHz，那么CPU_TS的单位就是1us

中断响应时间	指从中断被识别，到对应的中断服务程序开始执行 的时间，这个时间涵盖了中断机制引入的所有耗时
中断响应时间=中断延迟时间+中断向量映射时间+中断预处理时间

中断恢复时间	指从中断代码执行完毕，到接下来要执行的任务代码开始执行 的时间
这个“接下来的任务”，可能是被中断的任务，也可能是在中断服务程序中就绪的更高优先级的任务（中断处理任务）
任务等待时间	指某个任务从被中断  到 该任务代码重新开始执行  的时间